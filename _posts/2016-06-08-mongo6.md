---
layout: post
title:  "MongoDb aula 6!"
date:   2016-08-06 13:33:55 -0300
categories: start blog
---


### Relacionamentos

Não existe JOINS!!!
Então vc nao consegue fazer algo com uma chave estrangeira, e fazer um join e fazer essa busca automatica
de dois dados em coleçoes separadas, por exemplo, nao existe de forma automatica

## Manual
Existe duas formas, a manual eh a amais usada e eh a que vamos utilizar.
Para fazer um relacionamento manual basta você salvar o _id de uma coleção em outra. Por exemplo vamos criar nosso inventário de pokemons pegos nas suas pokebolas.

### Vamos criar o nosso array com tres obejetos de pokemons e vamos colocar no jason a ser inserido no nosso inventario
var pokemons = [
  {"_id": ObjectId("564b1dad25337263280d0479")},
  { "_id": ObjectId("564b1dad25337263280d047a")},
  {"_id": ObjectId("564b1dad25337263280d047b")}
];

## Vamos fazr um json bem simples, que o nome eh pokemons e que tem um campo pokemons que eh um array com ID dos pokemons da nossa colecao
var json = {
  name: "Meus pokemons",
  pokemons: pokemons,
  
}

#### Agora basta inserir eles, passando o json inventario
db.invt.insert(json)

## Vamos fazer uma busca para vê a nossa coleão inventarios.
db.invt.findOne()
{"_id": ObjectId("564b1dad25337263280d047a")
 {
  "_id": ObjectId("564b1dad25337263280d047b")
} }
 
##### Depois de inserido nossos pokemons vamos criar a busca para pegar cada um COMO UM SELECT

# Primiro criamos um array vazi e Depois criamos uma funcao chamada getpokemon.
var pokemons = []

## Essa funcao recebe esse ID e vai fazer o findOne e o push no nosso array de pokemons
var getPokemon = function(id){ pokemons.push(db.pokemons.findOne(id)) }

## Entao basta que fazemos o findOne no inventario
var invt = db.invt.findOne()

## Chamando nosso inventario temos um array chamado pokemons
invt
{"pokemons": 
[{"_id": ObjectId("564b1dad25337263280d0479")
  },{
    "_id": ObjectId("564b1dad25337263280d047a")
},]

### Entao podemos fazer um forEach, que eh um for interando so nos elemenos do array, e ele aceita a funcao getPokemon 
invt.pokemons.forEach(getPokemon)

# Agora vamos vê o nosso pokemons que estava vazio e que acabamos de criar.
pokemons
{"_id": ObjectId("564b1dad25337263280d047a"),
   "created": "2013-11-03T15:05:41.271082",
   "types": ["fire" ] },
{
  "_id": ObjectId("564b1dad25337263280d047b"),
 "hp": 58,
 "name": "Charmeleon",
 "types": ["fire" ]
}]

### DBRef
A outra forma que temo de referencia documentos no Mongodb é utilizando o dbref, ele nada mais eh que
uma convenção para representar um documento relacionado, isso inclui:


- $ref: nome da coleção a ser referenciada;
- $id: o ObjectId do documento referenciado;
- $db: a database onde a coleção referenciada se encontra.

### Explain
É o comando que mostra pra gente o que o banco ta fazendo, como ele execulta as query internamente

### O anderline rand a gente consegue um numero entre zero e um, e cada vez que chamar ele rola um numero aleatorio
 _rand()
0.0004714746028184891

 _rand()
0.7995197917334735

## Podemos usar isso para encontrar o registro aleatorio na base. 
 db.restaurantes.find().limit(1).skip( _rand() * db.restaurantes.count() )
{ 
  "name": "Jade Asian Bistro",
  "restaurant_id": "50005613"
}

### edir mais um vem um cara completamente diferente
db.restaurantes.find().limit(1).skip( _rand() * db.restaurantes.count() )

  "name": "Pizza Hut",
  "restaurant_id": "40716188"
}

### Vamos pegar um nome aleatorio  e depois dá um explain para vê seus processos
 db.restaurantes.find({ "name": "The Movable Feast" })

{  "name": "The Movable Feast",
  "restaurant_id": "40361606"
}

### Podemos fazer com qualquer query, operador, regex e etc. E utilizamos o explain para saber como a query rodou
db.restaurantes.find({ "name": "The Movable Feast" }).explain()
{
  "cursor": "BasicCursor",
  "isMultiKey": false,
 }
 
 ### Indices
 Indeces sao uma forma de falar para o nosso banco que esses sao os caras especiais, que vamos precisar rodar alguma coisa a partir deles
 
 Por exemplo, se eu faço uma certa operacao, e ela precisa ser muito rapida podemos pedir para o Mongo  Indexar a propriedade
 
 ### Se for vê nossa tabela so temos um indice, que eh o underline ID
db.restaurantes.getIndexes()
[  {"v": 1,
    "key": {
      "_id": 1
]

#### Para criar um indice, para ondem natural eh 1 e reversa 2, se vc quer a A  a Z ou de Z  a A 
db.restaurantes.createIndex ({ name: 1 })

### Fazendo o getIndex trazemos o name alem do ID que agora esta indexado
db.restaurantes.getIndexes()
[
  "ns": "be-mean.restaurantes",
  "name": "_id_"},
{"v": 1,
  "key": {
  "name": -1
 },

 O indice otimiza sua base para poder fazer pesquisa mais rapidas
 
 # GridFS
  É o sistema de arquivos do MongoDb o qual ira armazenar os arquivos binarios diretamente no banco
 
 Você pode querer guardar algum binário no banco porém o limite de cada documento BSON 
 é de 16 MB, logo se você quiser armazenar algo maior o GridFS é a ferramenta correta pro
 serviço.


E também se você não quiser que todo o arquivo vá para a memória RAM, isso é algo muito 
importante quando você está trabalhando com uma coleção grande de arquivos.
## Quando usar?
Tudo bem entendi que é para usar para armazenar arquivos maiores que 16 MB e que não vão para a memória, mas quando vou usar?

Em algumas situações, o armazenamento de arquivos grandes podem ser mais eficiente no MongoDB do que em um sistema de arquivos.Em

- Se seu sistema de arquivos limita o número de arquivos em um diretório, você pode usar GridFS para armazenar quantos arquivos quiser.

- Quando você quiser manter seus arquivos e metadados automaticamente sincronizados. Ao usar réplicas distribuídas geograficamente o MongoDB pode distribuir arquivos e seus metadados automaticamente.

- Quando você quiser acessar informações de partes de arquivos grandes sem ter que carregar todos os arquivos em memória, você pode usar GridFS buscar seções dos arquivos sem ler o arquivo inteiro na memória.

Não use GridFS se você precisar atualizar o conteúdo de todo o arquivo atomicamente. Como alternativa, você pode armazenar várias versões de cada arquivo e especificar a versão atual do arquivo nos metadados. 


Além disso, se seus arquivos são todos menores de 16MB, considere armazenar o arquivo manualmente dentro de um único documento. Você pode usar o tipo de dados `BinData` para armazenar os dados binários.

## Como usar? 
Para utilizar o GridFS, no terminal, usaremos o mongofiles passando o atributo -d nome_database para o nome da database onde iremos inserir o arquivo e `put nome_do_arquivo` para enviarmos o arquivo selecionado. Além disso pode ser necessário passar -h 127.0.0.1 para definir nosso host como local.





