---
layout: post
title:  "Python - Part 4:Funções, os blocos de construção do código"
date:   2017-07-11 16::51 -0300
categories: blog
---
Neste capítulo, vamos explorar as funções.i Mas, o que exatamente é uma função? Uma função é uma seqüência de 
instruções que executam uma tarefa, agrupada como uma unidade. Esta unidade pode ser importada e usada sempre
que for necessário. Há muitas vantagens em usar funções em seu código, como veremos em breve.

Acredito o ditado, uma imagem vale mais do que mil palavras, é particularmente verdade quando explicando
funções a alguém que é novo neste conceito, então por favor, veja a seguinte imagem:

Como você pode ver, uma função é um bloco de instruções, embalado como um todo, como uma caixa. As funções 
podem aceitar argumentos de entrada e produzir valores de saída. Ambos são Opcional, como veremos nos exemplos
deste capítulo.

Uma função em Python é definida usando a palavra-chave def, após a qual o nome de a função segue, terminada 
por um par de aparelhos (que pode ou não conter parâmetros de entrada) e, finalmente, um dois-pontos(:) 
sinaliza o fim da definição da função linha.

Imediatamente depois, indentado por quatro espaços, encontramos o corpo do Função, que é o conjunto de 
instruções que a função executará quando chamado.

**"""** Observe que a indentação por quatro espaços não é obrigatória, mas é A quantidade de espaços sugerida pelo 
PEP8 e, na prática, é o medida de espaçamento mais utilizada. **"""**

Uma função pode ou não retornar a saída. Se uma função quer retornar a saída, é um olho de águia, você pode 
ter notado um pequeno (*) após o opcional na seção de saída da imagem anterior.

Isso ocorre porque uma função sempre retorna algo no Python, mesmo que você Não use explicitamente a cláusula 
de devolução.

Se a função não tiver declaração de retorno em seu corpo, o valor de retorno é Nenhum. As razões por trás desta 
escolha de design estão fora do escopo de um capítulo introdutório, então tudo que você precisa saber é que esse 
comportamento tornará sua vida mais fácil, como sempre, agradecemos Python.

### Por que usar as funções?
As funções estão entre os conceitos e construções mais importantes de qualquer idioma,
Então deixe-me dar-lhe algumas razões pelas quais precisamos:

* Eles reduzem a duplicação de código em um programa. Ao ter uma tarefa específica cuidada por um bom bloco de código 
empacotado que podemos importar e ligar sempre que quisermos, não precisamos duplicar sua implementação.
* Eles ajudam a dividir uma tarefa ou procedimento complexo em blocos menores, cada um dos quais se torna uma função.
* Eles escondem os detalhes de implementação de seus usuários.
* Melhoram a rastreabilidade.
* Eles melhoram a legibilidade. Vejamos alguns exemplos para obter uma melhor compreensão de cada ponto.

Vejamos alguns exemplos para obter uma melhor compreensão de cada ponto.

### Reduza a duplicação de código
Imagine que você está escrevendo um pedaço de software científico, e você precisa calcular numeros primos até um limite, como 
fizemos no capítulo anterior. Você escreve vários algoritmos e números primos, sendo a base de muitos tipos diferentes
de cálculos, mantendo-se rastejando em seu código.

Bem, você tem um bom algoritmo para calculá-los, então você copiá-lo e colá-lo para onde você precisar. Um dia, no entanto, 
seu amigo Mister Smarty oferece um melhor algoritmo para calcular números primos, e isso vai lhe poupar muito tempo. Neste ponto,
você precisa passar por cima de sua base de código inteira e substituir o antigo Codifique com o novo código.

Esta é realmente uma maneira muito ruim de ir sobre isso. É propenso a erros, você nunca sabe quais linhas você está cortando ou 
deixando lá por engano quando você corta e cola código em outro código, e você também pode arriscar perder um dos lugares onde o 
cálculo principal foi feito, deixando seu software diferente versões.

Você pode imaginar se você descobriu que o caminho antigo era buggy? Você teria um Bug não detectado em seu código, e erros como 
este são bastante difíceis de detectar, especialmente em grandes bases de código.

Então o que você deveria fazer? Simples! Você escreve uma função, get_prime_numbers (upto), E use-o em qualquer lugar, você precisa
de uma lista de primos. Quando Mister Smarty vem até você e lhe dá o novo código, tudo o que você precisa fazer é substituir o corpo 
dessa função pela nova implementação, e você terminou! O resto do software se adaptará automaticamente, já que apenas está 
chamando a função.

Seu código será mais curto, não sofrerá inconsistências entre o antigo e as novas maneiras de realizar uma tarefa, ou erros não detectados 
devido a falhas de copiar e colar ou negligênciadas.

Use funções, e você só ganhará com isso, eu prometo.

### Divisão de uma tarefa complexa
As funções são muito úteis também para dividir uma tarefa longa ou complexa em peças menores. O resultado final é que o código se 
beneficia de várias maneiras, por exemplo, legibilidade, testabilidade e reutilização. Para dar um exemplo simples, imagine que você 
está preparando um relatório. Seu código precisa buscar dados de uma fonte e dados, analisá-lo, filtrar e polir ele, e então toda uma série 
de algoritmos precisa ser executada contra ele, para para produzir os resultados que irão alimentar a classe *Report*. Não é incomum ler 
procedimentos como esse que são apenas uma grande função *do_report(data_source)*. Existem dezenas ou centenas de linhas de código que 
terminam com relatório de retorno. 

Situações como esta são comuns em códigos produzidos por cientistas. Eles têm mentes brilhantes e eles se preocupam com a correção do
resultado final, mas, infelizmente, às vezes eles não têm treinamento na teoria da programação. Não é culpa dele, não se pode saber tudo. 
Agora, imagine em sua cabeça algo como algumas centenas Linhas de código. É muito difícil de seguir, encontrar os lugares onde as coisas
estão mudando o contexto (como terminar uma tarefa e começar a próxima).
```
def do_report(data_source):
# buscar e preparar data
    data = fetch_data(data_source)
    parsed_data = parse_data(data)
    filtered_data = filter_data(parsed_data)
    polished_data = polish_data(filtered_data)
# execute os algoritimos em data
    final_data = analyse(polished_data)
# criar e retornar relatorio
    report = Report(final_data)
    return report
```
Você tem imagem em sua mente? Bom. Não faça isso! Em vez disso, olhar para este código:

O exemplo anterior é fictício, é claro, mas você pode ver o quão fácil seria? Passar pelo código? Se o resultado final parecer errado, 
seria muito fácil de depurar Cada uma das saídas de dados únicas na função do_report. Além disso, é ainda mais fácil excluir parte do
processo temporariamente de todo o procedimento (você só precisa comentar as peças que você precisa para suspender). O código como esse
é mais fácil de lidar.

### Ocultar detalhes de implementação
Vamos ficar com o exemplo anterior para falar sobre esse ponto também. Você pode ver isso, ao passar pelo código da função *do_report*, 
você pode obter um bom entendimento sem ler uma única linha de implementação.

Isso ocorre porque as funções escondem os detalhes de implementação. Esta característica significa que, se você não precisa aprofundar 
os detalhes, você não é obrigado, do jeito que você faria, se o relatório *do_report* fosse apenas uma função grande.

Para entender o que estava acontecendo, você teria que ler os detalhes de implementação. Você não precisa com as funções. Isso reduz o
tempo que você passa ao ler o código e, em um ambiente profissional, o código de leitura leva muito mais tempo do que realmente escrevê-lo, 
é muito importante reduzir o máximo que pudermos.

### Melhorar a legibilidade
Coders às vezes não vêem o ponto em escrever uma função com um corpo de um ou dois linhas de código, então vejamos um exemplo que mostra 
o porquê você deve fazer isso.

Imagine que você precisa multiplicar duas matrizes:
```
a = [[1, 2], [3, 4]]
b = [[5, 1], [2, 1]]
c = [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]
    for r in a]
```
Ou preferiria este:
```
# Esta função também pode ser definida em outro módulo
def matrix_mul(a, b):
    return [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]
            for r in a]
a = [[1, 2], [3, 4]]
b = [[5, 1], [2, 1]]
c = matrix_mul(a, b)
```
É muito mais fácil entender que c é o resultado da multiplicação entre a e B no segundo exemplo. É muito mais fácil ler o código e, se você não 
precisa modificar essa parte, você nem precisa entrar nos detalhes de implementação.

Portanto, a legibilidade é melhorada aqui enquanto, no primeiro trecho, você faria tem que passar o tempo tentando entender o que essa lista 
complicada compreende o que estava fazendo.

**"""** Não se preocupe se não entender compreensões da lista, estudaremos eles no próximo capítulo. **"""**

### Melhorar a rastreabilidade

Imagine que você escreveu um site de comércio eletrônico. Você exibiu os preços dos produtos em todas as páginas. Imagine que os preços no seu 
banco de dados são armazenados sem VAT, mas você deseja exibi-los no site com vAT em 20%. Aqui estão algumas maneiras de calcular o preço do 
VAT a partir do preço exclusivo do VAT.
```
price = 100 # GBP, no VAT
final_price1 = price * 1.2
final_price2 = price + price / 5.0
final_price3 = price * (100 + 20) / 100.0
final_price4 = price + price * 0.2 
```
Todas estas quatro formas diferentes de calcular um preço com VAT são perfeitamente aceitável, e eu prometo que eu encontrei todos eles no código 
dos meus colegas, depois de anos.

Agora, imagine que você começou a vender seus produtos em diferentes países e alguns deles têm taxas de VAT diferentes, então você precisa
refatorar seu código (em todo o site) para tornar dinâmico esse cálculo de VAT.

Como você rastreia todos os lugares em que você está realizando um cálculo de VAT? Codificar hoje é uma tarefa colaborativa e você não pode
ter certeza de que o VAT foi calculado usando apenas uma dessas formas. Vai ser um inferno, acredite.

Então, vamos escrever uma função que leva os valores de entrada, VAT e preço(VAT-exclusive), e retorna um preço com VAT-inclusive.
```
def calculate_price_with_vat(price, vat):
    return price * (100 + vat) / 100
```
Agora você pode importar essa função e aplicá-la em qualquer lugar do seu site onde você precisa calcular um preço com VAT-inclusive e quando 
você precisa rastrear essas chamadas, Você pode procurar o *calculo_price_with_vat*

**"""**Observe que, no exemplo anterior, o preço é assumido como sendo VAT-exclusive, e o VAT tem um valor percentual(por exemplo,19, 20, 23
e assim por diante).**"""**

### Escopo e resolução de nomes
Você se lembra quando falamos sobre escopos e espaços de nomes no primeiro capítulo? Vamos agora expandir esse conceito. Finalmente, podemos 
falar sobre funções e isso tornará tudo mais fácil de entender. Vamos começar com um exemplo muito simples
```
def my_function():
    test = 1 # isso é definido no escorpo local da função
    print('my_function:', test)
test = 0 # isso é definido no escorpo global
my_function()
print('global:', test)
```
Defini o teste de nome em dois lugares diferentes no exemplo anterior está realmente em dois escopos diferentes. Um é o escopo global(teste = 0) 
e o outro é o escopo local da função my_function (teste = 1). Se você executar o código, você verá isso:
```
$ python3 scoping.level.1.py 
my_function: 1
global: 0
```
É claro que *teste = 1* e o teste de atribuição = 0 na *my_function*. No contexto global, o teste ainda é 0, como você pode ver na saída
do programa mas nós definimos o teste do nome novamente no corpo da função, e nós o definimos para apontar para um inteiro de valor 1. Ambos os 
dois nomes de teste portanto, existe um no escopo global, apontando para um objeto *int* com o valor 0, o outro no escopo *my_function*, apontando 
para um objeto *int* com valor 1. Vamos comentar a linha com o teste = 1. Python vai e procura o teste de nome no próximo espaço de nome
anexado(lembre-se da regra LEGB: Local, Enclosure, Global, Built-ini) e, neste caso, veremos o valor *0* impresso duas vezes.

No código anterior, temos dois níveis de sombreamento. Um nível está na função externa e o outro está na função interna.
Se executarmos o código, obtemos:

Tente comentar o teste de linha = 1. O que você acha que o resultado será? Bem, ao chegar à linha de impressão ('exterior:', teste),
Python terá que procurar teste no próximo escopo de encerramento, portanto, ele encontrará e imprime 0, em vez de 1.

Certifique-se de comentar testar = 2 também, para ver se você entende o que acontece e se a regra LEGB é clara antes de prosseguir.

Outra coisa a notar é que Python lhe dá a capacidade de definir uma função em outra função. O nome da função interna é definido dentro do
*namespace* da função externa, exatamente como aconteceria com qualquer outro *name*.

### As declarações globais e não-locais

Voltando ao exemplo anterior, podemos alterar o que acontece com o sombreamento, do *name* do teste usando uma dessas duas instruções
especiais: global e não local. Podemos obter acesso de leitura a esses nomes se os usarmos em um escopo aninhado que não defina-os, 
mas não podemos modificá-los porque, quando escrevemos uma instrução de tarefa, estamos realmente definindo um novo nome no escopo atual.

Como alteramos esse comportamento? Bem, podemos usar a declaração não local. De acordo com a documentação oficial: 

**"""**A declaração não local faz com que os identificadores listados se referem a variáveis previamente vinculadas no escopo envolvente
mais próximo excluindo globais**"""**.

Observe como no corpo da função interna eu declaro que o nome do teste deve ser Não local.

A execução deste código produz o seguinte resultado
```
$ python3 scorpin.level.2.nonlocal.py
inner: 2
outer: 2
global: 0
```
Uau, veja esse resultado! Isso significa que, ao declarar o teste como não local na função interna, nós realmente conseguimos vincular o 
teste de nome ao declarado na função externa.

Se removemos a linha de teste não-local da função interna e tentar o mesmo truque na função externa, teríamos uma SyntaxError, porque 
a declaração não local funciona nos escopos enclosing , excluindo o global.

Existe uma maneira de chegar a esse teste = 0 no espaço para nome global então? Claro,
Só precisamos usar a declaração global. Vamos tentar.
```
def outer():
    test = 1  # outer scope

    def inner():
        global test
        test = 2  # global scope
        print('inner:', test)

    inner()
    print('outer:', test)


test = 0  # global scope
outer()
print('global:', test)
```
Observe que agora declaramos que o teste do nome é global, o que basicamente Ligue-o ao que definimos no namespace global(teste = 0).

$ python scoping.level.2.global.py
inner: 2
outer: 1
global: 2

Isso mostra que o nome afetado pelo teste de atribuição = 2 é agora o global. Este truque também funcionaria na função externa porque, 
neste caso, estamos nos referindo para o escopo global. Experimente por si mesmo e veja o que muda, se sinta confortável com
Escopos e resolução de nomes, é muito importante.

### Parâmetros de entrada
No início deste capítulo, vimos que uma função pode ter parâmetros de entrada.

Antes de aprofundar todos os possíveis tipos de parâmetros, asseguremos que você tenha uma visão clara A compreensão do que passa um 
parâmetro para uma função significa. Há três pontos principais a ter em mente:

* A passagem de argumento é nada mais do que atribuir um objeto a um *name* da variável local
* Atribuir um objeto a um nome de argumento dentro de uma função não afeta sua chamada

• Alterar um argumento de objeto mutable em uma função afeta a chamada, vejamos um exemplo para cada um desses pontos.

### Passando Argumento 

Dê uma olhada no seguinte código. Declaramos um nome*(x)* no escopo global, então declaramos uma função func*(y)* e chamamos isso,
passando (x). destaquei o chamador no código
```
$ key.points.argument.passing.py
x = 3
    def func(y):
print(y)
func(x) # prints: 3
```
A parte direita da imagem anterior mostra o estado do programa quando a execução chegou ao fim, depois que func retornou (Nenhum). Dê
uma olhada na coluna *Frames* e note que temos dois names, *x* e *func*, no namespace global(quadro global), apontando para um *int*(com um valor de três)
e para um objeto de função, respectivamente.

Logo abaixo, no retângulo intitulado func, podemos ver o espaço de nomes local da função, em Que apenas um nome foi definido: y. Por ter chamado func com
x(linha 5 na parte esquerda da imagem), y está apontando para o mesmo objeto que x está apontando para.

Isto é o que acontece sob o capô quando um argumento é passado para uma função. Isto é o que acontece sob o capô quando um argumento é passado para uma função.

Se usássemos o nome x em vez de y na definição da função, as coisas teriam sido exatamente as mesmas (só talvez um pouco confuso no início), haveria um *x*
local na função, e um x global fora, como nós Viu na seção Scopes e resolução de nomes.

Então, em poucas palavras, o que realmente acontece é que a função cria em seu escopo local Os nomes definidos como argumentos e, quando o chamamos, 
basicamente dizemos a Python que Os objetos em que os nomes devem ser apontados.










