---
layout: post
title:  "Python - Part 4:Funções, os blocos de construção do código"
date:   2017-07-11 16::51 -0300
categories: blog
---
Neste capítulo, vamos explorar as funções.i Mas, o que exatamente é uma função? Uma função é uma seqüência de 
instruções que executam uma tarefa, agrupada como uma unidade. Esta unidade pode ser importada e usada sempre
que for necessário. Há muitas vantagens em usar funções em seu código, como veremos em breve.

Acredito o ditado, uma imagem vale mais do que mil palavras, é particularmente verdade quando explicando
funções a alguém que é novo neste conceito, então por favor, veja a seguinte imagem:

Como você pode ver, uma função é um bloco de instruções, embalado como um todo, como uma caixa. As funções 
podem aceitar argumentos de entrada e produzir valores de saída. Ambos são Opcional, como veremos nos exemplos
deste capítulo.

Uma função em Python é definida usando a palavra-chave def, após a qual o nome de a função segue, terminada 
por um par de aparelhos (que pode ou não conter parâmetros de entrada) e, finalmente, um dois-pontos(:) 
sinaliza o fim da definição da função linha.

Imediatamente depois, indentado por quatro espaços, encontramos o corpo do Função, que é o conjunto de 
instruções que a função executará quando chamado.

**"""** Observe que a indentação por quatro espaços não é obrigatória, mas é A quantidade de espaços sugerida pelo 
PEP8 e, na prática, é o medida de espaçamento mais utilizada. **"""**

Uma função pode ou não retornar a saída. Se uma função quer retornar a saída, é um olho de águia, você pode 
ter notado um pequeno (*) após o opcional na seção de saída da imagem anterior.

Isso ocorre porque uma função sempre retorna algo no Python, mesmo que você Não use explicitamente a cláusula 
de devolução.

Se a função não tiver declaração de retorno em seu corpo, o valor de retorno é Nenhum. As razões por trás desta 
escolha de design estão fora do escopo de um capítulo introdutório, então tudo que você precisa saber é que esse 
comportamento tornará sua vida mais fácil, como sempre, agradecemos Python.

### Por que usar as funções?
As funções estão entre os conceitos e construções mais importantes de qualquer idioma,
Então deixe-me dar-lhe algumas razões pelas quais precisamos:

* Eles reduzem a duplicação de código em um programa. Ao ter uma tarefa específica cuidada por um bom bloco de código 
empacotado que podemos importar e ligar sempre que quisermos, não precisamos duplicar sua implementação.
* Eles ajudam a dividir uma tarefa ou procedimento complexo em blocos menores, cada um dos quais se torna uma função.
* Eles escondem os detalhes de implementação de seus usuários.
* Melhoram a rastreabilidade.
* Eles melhoram a legibilidade. Vejamos alguns exemplos para obter uma melhor compreensão de cada ponto.

Vejamos alguns exemplos para obter uma melhor compreensão de cada ponto.

### Reduza a duplicação de código
Imagine que você está escrevendo um pedaço de software científico, e você precisa calcular numeros primos até um limite, como 
fizemos no capítulo anterior. Você escreve vários algoritmos e números primos, sendo a base de muitos tipos diferentes
de cálculos, mantendo-se rastejando em seu código.

Bem, você tem um bom algoritmo para calculá-los, então você copiá-lo e colá-lo para onde você precisar. Um dia, no entanto, 
seu amigo Mister Smarty oferece um melhor algoritmo para calcular números primos, e isso vai lhe poupar muito tempo. Neste ponto,
você precisa passar por cima de sua base de código inteira e substituir o antigo Codifique com o novo código.

Esta é realmente uma maneira muito ruim de ir sobre isso. É propenso a erros, você nunca sabe quais linhas você está cortando ou 
deixando lá por engano quando você corta e cola código em outro código, e você também pode arriscar perder um dos lugares onde o 
cálculo principal foi feito, deixando seu software diferente versões.

Você pode imaginar se você descobriu que o caminho antigo era buggy? Você teria um Bug não detectado em seu código, e erros como 
este são bastante difíceis de detectar, especialmente em grandes bases de código.

Então o que você deveria fazer? Simples! Você escreve uma função, get_prime_numbers (upto), E use-o em qualquer lugar, você precisa
de uma lista de primos. Quando Mister Smarty vem até você e lhe dá o novo código, tudo o que você precisa fazer é substituir o corpo 
dessa função pela nova implementação, e você terminou! O resto do software se adaptará automaticamente, já que apenas está 
chamando a função.

Seu código será mais curto, não sofrerá inconsistências entre o antigo e as novas maneiras de realizar uma tarefa, ou erros não detectados 
devido a falhas de copiar e colar ou negligênciadas.

Use funções, e você só ganhará com isso, eu prometo.

### Divisão de uma tarefa complexa
As funções são muito úteis também para dividir uma tarefa longa ou complexa em peças menores. O resultado final é que o código se 
beneficia de várias maneiras, por exemplo, legibilidade, testabilidade e reutilização. Para dar um exemplo simples, imagine que você 
está preparando um relatório. Seu código precisa buscar dados de uma fonte e dados, analisá-lo, filtrar e polir ele, e então toda uma série 
de algoritmos precisa ser executada contra ele, para para produzir os resultados que irão alimentar a classe *Report*. Não é incomum ler 
procedimentos como esse que são apenas uma grande função *do_report(data_source)*. Existem dezenas ou centenas de linhas de código que 
terminam com relatório de retorno. 

Situações como esta são comuns em códigos produzidos por cientistas. Eles têm mentes brilhantes e eles se preocupam com a correção do
resultado final, mas, infelizmente, às vezes eles não têm treinamento na teoria da programação. Não é culpa dele, não se pode saber tudo. 
Agora, imagine em sua cabeça algo como algumas centenas Linhas de código. É muito difícil de seguir, encontrar os lugares onde as coisas
estão mudando o contexto (como terminar uma tarefa e começar a próxima).
```
def do_report(data_source):
# buscar e preparar data
    data = fetch_data(data_source)
    parsed_data = parse_data(data)
    filtered_data = filter_data(parsed_data)
    polished_data = polish_data(filtered_data)
# execute os algoritimos em data
    final_data = analyse(polished_data)
# criar e retornar relatorio
    report = Report(final_data)
    return report
```
Você tem imagem em sua mente? Bom. Não faça isso! Em vez disso, olhar para este código:

O exemplo anterior é fictício, é claro, mas você pode ver o quão fácil seria? Passar pelo código? Se o resultado final parecer errado, 
seria muito fácil de depurar Cada uma das saídas de dados únicas na função do_report. Além disso, é ainda mais fácil excluir parte do
processo temporariamente de todo o procedimento (você só precisa comentar as peças que você precisa para suspender). O código como esse
é mais fácil de lidar.

### Ocultar detalhes de implementação
Vamos ficar com o exemplo anterior para falar sobre esse ponto também. Você pode ver isso, ao passar pelo código da função *do_report*, 
você pode obter um bom entendimento sem ler uma única linha de implementação.

Isso ocorre porque as funções escondem os detalhes de implementação. Esta característica significa que, se você não precisa aprofundar 
os detalhes, você não é obrigado, do jeito que você faria, se o relatório do_report fosse apenas uma função grande.

Para entender o que estava acontecendo, você teria que ler os detalhes de implementação. Você não precisa com as funções.  Isso reduz o
tempo que você passa ao ler o código e, em um ambiente profissional, o código de leitura leva muito mais tempo do que realmente escrevê-lo, 
é muito importante reduzir o máximo que pudermos.
































