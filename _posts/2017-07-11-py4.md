---
layout: post
title:  "Python Part 4 - Funções, os blocos de construção do código"

date:   2017-07-11 16::51 -0300
categories: blog
---
Neste capítulo, vamos explorar as funções. Mas, o que exatamente é uma função? Uma função é uma seqüência de instruções
que executam uma tarefa, agrupada como uma unidade. Esta unidade pode ser importada e usada sempre que for necessário. 
Há muitas vantagens em usar funções em seu código, como veremos em breve.

Acredito o ditado, uma imagem vale mais do que mil palavras, é particularmente verdade quando explicando funções a alguém 
ue é novo neste conceito, então por favor, veja a seguinte imagem:

[img]

Como você pode ver, uma função é um bloco de instruções, embalado como um todo, como uma caixa. As funções 
podem aceitar argumentos de entrada e produzir valores de saída. Ambos são opcional, como veremos nos exemplos

deste capítulo.

Uma função em Python é definida usando a palavra-chave def, após a qual o nome de a função segue, terminada 
por um par de aparelhos (que pode ou não conter parâmetros de entrada) e, finalmente, um dois-pontos(:) 
sinaliza o fim da definição da função linha.

Imediatamente depois, indentado por quatro espaços, encontramos o corpo do Função, que é o conjunto de 
instruções que a função executará quando chamado.

**"""** Observe que a indentação por quatro espaços não é obrigatória, mas é A quantidade de espaços sugerida pelo 
PEP8 e, na prática, é o medida de espaçamento mais utilizada. **"""**

Uma função pode ou não retornar a saída. Se uma função quer retornar a saída, é um olho de águia, você pode 
ter notado um pequeno (*) após o opcional na seção de saída da imagem anterior.

Isso ocorre porque uma função sempre retorna algo no Python, mesmo que você Não use explicitamente a cláusula 
de devolução.

Se a função não tiver declaração de retorno em seu corpo, o valor de retorno é Nenhum. As razões por trás desta 
escolha de design estão fora do escopo de um capítulo introdutório, então tudo que você precisa saber é que esse 
comportamento tornará sua vida mais fácil, como sempre, agradecemos Python.

### Por que usar as funções?
As funções estão entre os conceitos e construções mais importantes de qualquer idioma,
Então deixe-me dar-lhe algumas razões pelas quais precisamos:

* Eles reduzem a duplicação de código em um programa. Ao ter uma tarefa específica cuidada por um bom bloco de código 
empacotado que podemos importar e ligar sempre que quisermos, não precisamos duplicar sua implementação.
* Eles ajudam a dividir uma tarefa ou procedimento complexo em blocos menores, cada um dos quais se torna uma função.
* Eles escondem os detalhes de implementação de seus usuários.
* Melhoram a rastreabilidade.
* Eles melhoram a legibilidade. Vejamos alguns exemplos para obter uma melhor compreensão de cada ponto.

Vejamos alguns exemplos para obter uma melhor compreensão de cada ponto.

### Reduza a duplicação de código
Imagine que você está escrevendo um pedaço de software científico, e você precisa calcular numeros primos até um limite, como 
fizemos no capítulo anterior. Você escreve vários algoritmos e números primos, sendo a base de muitos tipos diferentes
de cálculos, mantendo-se rastejando em seu código.

Bem, você tem um bom algoritmo para calculá-los, então você copiá-lo e colá-lo para onde você precisar. Um dia, no entanto, 
seu amigo Mister Smarty oferece um melhor algoritmo para calcular números primos, e isso vai lhe poupar muito tempo. Neste ponto,
você precisa passar por cima de sua base de código inteira e substituir o antigo Codifique com o novo código.

Esta é realmente uma maneira muito ruim de ir sobre isso. É propenso a erros, você nunca sabe quais linhas você está cortando ou 
deixando lá por engano quando você corta e cola código em outro código, e você também pode arriscar perder um dos lugares onde o 
cálculo principal foi feito, deixando seu software diferente versões.

Você pode imaginar se você descobriu que o caminho antigo era buggy? Você teria um Bug não detectado em seu código, e erros como 
este são bastante difíceis de detectar, especialmente em grandes bases de código.

Então o que você deveria fazer? Simples! Você escreve uma função, get_prime_numbers (upto), E use-o em qualquer lugar, você precisa
de uma lista de primos. Quando Mister Smarty vem até você e lhe dá o novo código, tudo o que você precisa fazer é substituir o corpo 
dessa função pela nova implementação, e você terminou! O resto do software se adaptará automaticamente, já que apenas está 
chamando a função.

Seu código será mais curto, não sofrerá inconsistências entre o antigo e as novas maneiras de realizar uma tarefa, ou erros não detectados 
devido a falhas de copiar e colar ou negligênciadas.

Use funções, e você só ganhará com isso, eu prometo.

### Divisão de uma tarefa complexa
As funções são muito úteis também para dividir uma tarefa longa ou complexa em peças menores. O resultado final é que o código se 
beneficia de várias maneiras, por exemplo, legibilidade, testabilidade e reutilização. Para dar um exemplo simples, imagine que você 
está preparando um relatório. Seu código precisa buscar dados de uma fonte e dados, analisá-lo, filtrar e polir ele, e então toda uma série 
de algoritmos precisa ser executada contra ele, para para produzir os resultados que irão alimentar a classe *Report*. Não é incomum ler 
procedimentos como esse que são apenas uma grande função *do_report(data_source)*. Existem dezenas ou centenas de linhas de código que 
terminam com relatório de retorno. 

Situações como esta são comuns em códigos produzidos por cientistas. Eles têm mentes brilhantes e eles se preocupam com a correção do
resultado final, mas, infelizmente, às vezes eles não têm treinamento na teoria da programação. Não é culpa dele, não se pode saber tudo. 
Agora, imagine em sua cabeça algo como algumas centenas Linhas de código. É muito difícil de seguir, encontrar os lugares onde as coisas
estão mudando o contexto (como terminar uma tarefa e começar a próxima).
```
def do_report(data_source):
# buscar e preparar data
    data = fetch_data(data_source)
    parsed_data = parse_data(data)
    filtered_data = filter_data(parsed_data)
    polished_data = polish_data(filtered_data)
# execute os algoritimos em data
    final_data = analyse(polished_data)
# criar e retornar relatorio
    report = Report(final_data)
    return report
```
Você tem imagem em sua mente? Bom. Não faça isso! Em vez disso, olhar para este código:

O exemplo anterior é fictício, é claro, mas você pode ver o quão fácil seria? Passar pelo código? Se o resultado final parecer errado, 
seria muito fácil de depurar Cada uma das saídas de dados únicas na função do_report. Além disso, é ainda mais fácil excluir parte do
processo temporariamente de todo o procedimento (você só precisa comentar as peças que você precisa para suspender). O código como esse
é mais fácil de lidar.

### Ocultar detalhes de implementação
Vamos ficar com o exemplo anterior para falar sobre esse ponto também. Você pode ver isso, ao passar pelo código da função *do_report*, 
você pode obter um bom entendimento sem ler uma única linha de implementação.

Isso ocorre porque as funções escondem os detalhes de implementação. Esta característica significa que, se você não precisa aprofundar 
os detalhes, você não é obrigado, do jeito que você faria, se o relatório *do_report* fosse apenas uma função grande.

Para entender o que estava acontecendo, você teria que ler os detalhes de implementação. Você não precisa com as funções. Isso reduz o
tempo que você passa ao ler o código e, em um ambiente profissional, o código de leitura leva muito mais tempo do que realmente escrevê-lo, 
é muito importante reduzir o máximo que pudermos.

### Melhorar a legibilidade
Coders às vezes não vêem o ponto em escrever uma função com um corpo de um ou dois linhas de código, então vejamos um exemplo que mostra 
o porquê você deve fazer isso.

Imagine que você precisa multiplicar duas matrizes:
```
a = [[1, 2], [3, 4]]
b = [[5, 1], [2, 1]]
c = [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]
    for r in a]
```
Ou preferiria este:
```
# Esta função também pode ser definida em outro módulo
def matrix_mul(a, b):
    return [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]
            for r in a]
a = [[1, 2], [3, 4]]
b = [[5, 1], [2, 1]]
c = matrix_mul(a, b)
``
É muito mais fácil entender que c é o resultado da multiplicação entre a e B no segundo exemplo. É muito mais fácil ler o código e, se você não 
precisa modificar essa parte, você nem precisa entrar nos detalhes de implementação.

Portanto, a legibilidade é melhorada aqui enquanto, no primeiro trecho, você faria tem que passar o tempo tentando entender o que essa lista 
complicada compreende o que estava fazendo.

**"""** Não se preocupe se não entender compreensões da lista, estudaremos eles no próximo capítulo. **"""**

### Melhorar a rastreabilidade

Imagine que você escreveu um site de comércio eletrônico. Você exibiu os preços dos produtos em todas as páginas. Imagine que os preços no seu 
banco de dados são armazenados sem VAT, mas você deseja exibi-los no site com vAT em 20%. Aqui estão algumas maneiras de calcular o preço do 
VAT a partir do preço exclusivo do VAT.
```
price = 100 # GBP, no VAT
final_price1 = price * 1.2
final_price2 = price + price / 5.0
final_price3 = price * (100 + 20) / 100.0
final_price4 = price + price * 0.2 
```
Todas estas quatro formas diferentes de calcular um preço com VAT são perfeitamente aceitável, e eu prometo que eu encontrei todos eles no código 
dos meus colegas, depois de anos.

Agora, imagine que você começou a vender seus produtos em diferentes países e alguns deles têm taxas de VAT diferentes, então você precisa
refatorar seu código (em todo o site) para tornar dinâmico esse cálculo de VAT.

Como você rastreia todos os lugares em que você está realizando um cálculo de VAT? Codificar hoje é uma tarefa colaborativa e você não pode
ter certeza de que o VAT foi calculado usando apenas uma dessas formas. Vai ser um inferno, acredite.

Então, vamos escrever uma função que leva os valores de entrada, VAT e preço(VAT-exclusive), e retorna um preço com VAT-inclusive.
```
def calculate_price_with_vat(price, vat):
    return price * (100 + vat) / 100
```
Agora você pode importar essa função e aplicá-la em qualquer lugar do seu site onde você precisa calcular um preço com VAT-inclusive e quando 
você precisa rastrear essas chamadas, Você pode procurar o *calculo_price_with_vat*

**"""**Observe que, no exemplo anterior, o preço é assumido como sendo VAT-exclusive, e o VAT tem um valor percentual(por exemplo,19, 20, 23
e assim por diante).**"""**

### Escopo e resolução de nomes
Você se lembra quando falamos sobre escopos e espaços de nomes no primeiro capítulo? Vamos agora expandir esse conceito. Finalmente, podemos 
falar sobre funções e isso tornará tudo mais fácil de entender. Vamos começar com um exemplo muito simples
```
def my_function():
    test = 1 # isso é definido no escorpo local da função
    print('my_function:', test)
test = 0 # isso é definido no escorpo global
my_function()
print('global:', test)
```
Defini o teste de nome em dois lugares diferentes no exemplo anterior está realmente em dois escopos diferentes. Um é o escopo global(teste = 0) 
e o outro é o escopo local da função my_function (teste = 1). Se você executar o código, você verá isso:
```
$ python3 scoping.level.1.py 
my_function: 1
global: 0
```
É claro que *teste = 1* e o teste de atribuição = 0 na *my_function*. No contexto global, o teste ainda é 0, como você pode ver na saída
do programa mas nós definimos o teste do nome novamente no corpo da função, e nós o definimos para apontar para um inteiro de valor 1. Ambos os 
dois nomes de teste portanto, existe um no escopo global, apontando para um objeto *int* com o valor 0, o outro no escopo *my_function*, apontando 
para um objeto *int* com valor 1. Vamos comentar a linha com o teste = 1. Python vai e procura o teste de nome no próximo espaço de nome
anexado(lembre-se da regra LEGB: Local, Enclosure, Global, Built-ini) e, neste caso, veremos o valor *0* impresso duas vezes.

No código anterior, temos dois níveis de sombreamento. Um nível está na função externa e o outro está na função interna.
Se executarmos o código, obtemos:

Tente comentar o teste de linha = 1. O que você acha que o resultado será? Bem, ao chegar à linha de impressão ('exterior:', teste),
Python terá que procurar teste no próximo escopo de encerramento, portanto, ele encontrará e imprime 0, em vez de 1.

Certifique-se de comentar testar = 2 também, para ver se você entende o que acontece e se a regra LEGB é clara antes de prosseguir.

Outra coisa a notar é que Python lhe dá a capacidade de definir uma função em outra função. O nome da função interna é definido dentro do
*namespace* da função externa, exatamente como aconteceria com qualquer outro *name*.

### As declarações globais e não-locais
Voltando ao exemplo anterior, podemos alterar o que acontece com o sombreamento, do *name* do teste usando uma dessas duas instruções
especiais: global e não local. Podemos obter acesso de leitura a esses nomes se os usarmos em um escopo aninhado que não defina-os, 
mas não podemos modificá-los porque, quando escrevemos uma instrução de tarefa, estamos realmente definindo um novo nome no escopo atual.

Como alteramos esse comportamento? Bem, podemos usar a declaração não local. De acordo com a documentação oficial: 

**"""**A declaração não local faz com que os identificadores listados se referem a variáveis previamente vinculadas no escopo envolvente
mais próximo excluindo globais**"""**.

Observe como no corpo da função interna eu declaro que o nome do teste deve ser Não local.

A execução deste código produz o seguinte resultado
```
$ python3 scorpin.level.2.nonlocal.py
inner: 2
outer: 2
global: 0
```
Uau, veja esse resultado! Isso significa que, ao declarar o teste como não local na função interna, nós realmente conseguimos vincular o 
teste de nome ao declarado na função externa.

Se removemos a linha de teste não-local da função interna e tentar o mesmo truque na função externa, teríamos uma SyntaxError, porque 
a declaração não local funciona nos escopos enclosing , excluindo o global.

Existe uma maneira de chegar a esse teste = 0 no espaço para nome global então? Claro,
Só precisamos usar a declaração global. Vamos tentar.
```
def outer():
    test = 1  # outer scope

    def inner():
        global test
        test = 2  # global scope
        print('inner:', test)

    inner()
    print('outer:', test)


test = 0  # global scope
outer()
print('global:', test)
```
Observe que agora declaramos que o teste do nome é global, o que basicamente Ligue-o ao que definimos no namespace global(teste = 0).

$ python scoping.level.2.global.py
inner: 2
outer: 1
global: 2

Isso mostra que o nome afetado pelo teste de atribuição = 2 é agora o global. Este truque também funcionaria na função externa porque, 
neste caso, estamos nos referindo para o escopo global. Experimente por si mesmo e veja o que muda, se sinta confortável com
Escopos e resolução de nomes, é muito importante.

### Parâmetros de entrada
No início deste capítulo, vimos que uma função pode ter parâmetros de entrada.

Antes de aprofundar todos os possíveis tipos de parâmetros, asseguremos que você tenha uma visão clara A compreensão do que passa um 
parâmetro para uma função significa. Há três pontos principais a ter em mente:

* A passagem de argumento é nada mais do que atribuir um objeto a um *name* da variável local
* Atribuir um objeto a um nome de argumento dentro de uma função não afeta sua chamada

• Alterar um argumento de objeto mutable em uma função afeta a chamada, vejamos um exemplo para cada um desses pontos.

### Passando Argumento 
Dê uma olhada no seguinte código. Declaramos um nome*(x)* no escopo global, então declaramos uma função func*(y)* e chamamos isso,
passando (x). destaquei o chamador no código
```
$ key.points.argument.passing.py
x = 3
    def func(y):
print(y)
func(x) # prints: 3
```
A parte direita da imagem anterior mostra o estado do programa quando a execução chegou ao fim, depois que func retornou (Nenhum). Dê
uma olhada na coluna *Frames* e note que temos dois names, *x* e *func*, no namespace global(quadro global), apontando para um *int*(com um valor de três)
e para um objeto de função, respectivamente.

Logo abaixo, no retângulo intitulado func, podemos ver o espaço de nomes local da função, em Que apenas um nome foi definido: y. Por ter chamado func com
x(linha 5 na parte esquerda da imagem), y está apontando para o mesmo objeto que x está apontando para.

Isto é o que acontece sob o capô quando um argumento é passado para uma função. Isto é o que acontece sob o capô quando um argumento é passado para uma função.

Se usássemos o nome x em vez de y na definição da função, as coisas teriam sido exatamente as mesmas (só talvez um pouco confuso no início), haveria um *x*
local na função, e um x global fora, como nós Viu na seção Scopes e resolução de nomes.

Então, em poucas palavras, o que realmente acontece é que a função cria em seu escopo local Os nomes definidos como argumentos e, quando o chamamos, 
basicamente dizemos a Python que Os objetos em que os nomes devem ser apontados.

### A atribuição de nomes de argumentos não afeta a chamada
Isso é algo que pode ser complicado de entender no início, então vejamos um exemplo.
```
x = 3
def func(x):
    x = 7 # definindo um x local, não mudando o global

func(x)
print(x) # prints: 3
```
No código anterior, quando a linha x = 7 é executada, o que acontece é que, dentro de O escopo local da função func, o nome x é apontado para um
número inteiro com o valor 7, deixando o global x inalterado.

### Alterar um mutable afeta o chamador

Este é o ponto final, e é muito importante porque o Python aparentemente se comporta de forma diferente com mutables(aparentemente embora). 
Vejamos um exemplo:
```
x = [1, 2, 3]
def func(x):
    x[1] = 42

func(x)
print(x)
```
$ python3 key.points.mutable.py 
[1, 42, 3]

Uau, nós realmente mudamos o objeto original! Se você pensa sobre isso, não há nada estranho neste comportamento. O nome *x* na função é definido para
apontar para o objeto do chamador pela chamada da função e dentro do corpo da função, não estamos mudando *x*, na medida em que não estamos mudando sua
referência ou, em outras palavras, nós não está mudando o objeto *x* apontando para.

O que estamos fazendo é acessar o elemento desse objeto na posição 1 e mudar seu valor. Lembre-se do ponto # 2: "Atribuir um objeto a um nome de 
argumento dentro de uma função não Afetar o chamador ". Se isso for claro para você, o código a seguir não deve ser surpreendente.

Dê uma olhada nas duas linhas que destaquei. Em primeiro lugar, acabamos de acessar novamente o objeto do chamador, 
na posição 1, e alteramos seu valor para o número 42.

Então, reatribuímos x para apontar para a string 'outra coisa'. Isso deixa o interlocutor inalterado, de acordo com o ponto 2, e, de fato, 
a saída é a mesma do fragmento anterior.

Aproveite o tempo para brincar com este conceito e experimentar impressões e chamadas para a função id até que tudo esteja claro em sua mente. Este é um dos 
principais aspectos do Python e deve ser muito claro, caso contrário você arrisca a introduzir erros sutis em seu código.

Agora que temos uma boa compreensão dos parâmetros de entrada e como eles se comportam, Vamos ver como podemos especificá-los

### Como especificar parâmetros de entrada
Existem cinco maneiras diferentes de especificar os parâmetros de entrada. Vamos olhar para eles um por um.

### Argumentos posicionais
Os argumentos posicionais são lidos da esquerda para a direita e são o tipo mais comum de argumentos.
```
def func(a, b, c):
    print(a, b, c)

func(1, 2, 3) # prints: 1 2 3
```
$ python3 arguments.positional.py 
1 2 3

Não há muito mais a dizer. Eles podem ser tão numerosos quanto você deseja e são atribuídos por posição. Na chamada de função, 1 vem em primeiro lugar, 2 vem em 
segundo e 3 vem em terceiro lugar, portanto são atribuídos a, b e c, respectivamente.

### Argumentos das palavras-chave e valores padrão

Os argumentos das palavras-chave são atribuídos por palavra-chave usando a sintaxe *name=value*.
```
def func(a, b, c):
    print(a, b, c)

func(a=1, c=2, b=3) # prints: 1 3 2
```
Os argumentos das palavras-chave atuam ao chamar a função em vez de respeitar a atribuição do posicionamento da esquerda para a direita, k. Os argumentos de 
palavras-chave são combinados pelo nome, mesmo quando não respeitam a posição original da definição(veremos que há uma limitação para esse comportamento 
mais tarde, quando misturamos e combinamos diferentes tipos de argumentos).

A contrapartida dos argumentos de palavras-chave, no lado da definição, são valores padrão. sintaxe é a mesma, *nome=valor*, e nos permite não ter 
que fornecer um argumento se estamos felizes com o padrão especificado. 
```
def func(a, b=4, c=88):
    print(a, b, c)

func(1) # prints: 1 4 88
func(b=5, a=7, c=9) # prints: 7 5 9
func(42, c=9) # prints: 42 4 9
```
São duas coisas a notar, que são muito importantes. Em primeiro lugar, você não pode especificar um argumento padrão à esquerda de um posicional.

Em segundo lugar, observe como nos exemplos, quando um argumento é passado sem usar a sintaxe *argumento_nome=valor*, ele deve ser o primeiro na lista,
e sempre é atribuído à a.

Tente mexer com esses argumentos e veja o que acontece. As mensagens de erro do Python são muito boas em dizer o que está errado. Então, por exemplo,
se você tentou algo como isto

Func (b = 1, c = 2, 42) # argumento posicional após uma  palavra-chave

Isso informa que você chamou a função incorretamente.

### Argumentos posicionais variáveis
Às vezes você pode querer passar um número variável de argumentos posicionais para uma função e o Python oferece a capacidade de fazê-lo.
Vejamos um caso de uso muito comum, a função mínima. Esta é uma função que calcula o mínimo de seus valores de entrada.

```
def minimum(*n):
    #print(n) # n é uma tupla
    if n: # explicado depois do codigo
        mn = n[0]
        for value in n[1:]:
            if value < mn:
                mn = value
        print(mn)

minimum(1, 3, -7, 9) # n = (1, 3, -7, 9) - prints: -7
minimum() # n = () - prints: nada
```
Como você pode ver, quando especificamos um parâmetro que precede (a*) ao seu nome, estamos dizendo a Python que esse parâmetro irá coletar um 
número de variável da posição dos argumentos, de acordo com a forma como a função é chamada. Dentro da função, *n* é uma tupla. Descomente o 
print(n) para ver por si mesmo e brincar com ela por um pouco.


**"""** Você notou como verificamos se *n* não estava vazio com um simples *IF n:*? Isto é devido ao fato de que os objetos de coleção se classificam 
para *True* quando Não vazio, e de outra forma *False* em Python. Isso é válido para tuplas, conjuntos, listas, dicionários, e assim por diante. Outra 
coisa a notar é que podemos querer dar um erro quando nós chamamos a função sem argumentos, em vez de silenciosamente não fazer nada. Neste contexto, 
não estamos preocupados em tornar esta função robusta, mas na compreensão de argumentos posicionais variáveis. **"""**

Vamos fazer outro exemplo para mostrar duas coisas que, na minha experiência, são confuso para aqueles que são novos para isso.
```
def func(*args):
    print(args)

values = (1, 3, -7, 9)
func(values) # equivalente a: func((1, 3, -7, 9))
func(*values) # equivalent a: func(1, 3, -7, 9)
```
Dê uma boa olhada nas duas últimas linhas do exemplo anterior. No primeiro, chamamos de func com um argumento, uma tupla de quatro elementos. 
No segundo exemplo, usando a sintaxe (*), estamos fazendo algo chamado de desembalagem, o que significa que a tupla de quatro elementos é 
descompactada e a função é chamada com quatro argumentos: 1, 3, -7, 9.

Esse comportamento é parte do mágico Python faz para permitir que você faça coisas incríveis o chamar funções dinamicamente

### Argumentos de palavras-chave variáveis
Os argumentos de palavras-chave variáveis são muito semelhantes aos argumentos posicionais variáveis.

A única diferença é a sintaxe (** em vez de *) e que são coletadas em
um dicionário.

Trabalhos de coleção e desembarque da mesma forma, então vejamos um
exemplo:
```
def func(**kwargs):
    print(kwargs) 
# Todas as chamadas equivalentes. Eles imprimem: {'a': 1, 'b': 42}    
func(a=1, b=42)
func(**{'a': 1, 'b': 42})
func(**dict(a=1, b=42))
```
Todas as chamadas são equivalentes no exemplo anterior. Você pode ver que adicionamos um (**) na frente do nome do parâmetro na
definição da função diz ao Python que use esse nome para coletar um número variável de parâmetros de palavras-chave.

Por outro lado, quando chamamos a função, podemos passar nomes = argumentos de valor explicitamente ou descompactar um dicionário 
usando a mesma sintaxe **.

A razão pela qual poder passar um número variável de parâmetros de palavras-chave é Tão importante pode não ser evidente no momento, 
então, e quanto a uma realidade mais realista? exemplo? Vamos definir uma função que se conecta a um banco de dados.

Queremos conectar-se a um banco de dados padrão simplesmente chamando esta função sem parâmetros. Antes de ler, gaste alguns minutos 
descobrindo uma solução sozinho.
```
def connect(**options):
    conn_params = {
        'host': options.get('host', '127.0.0.1'),
        'port': options.get('port', 5432),
        'user': options.get('user', ''),
        'pwd': options.get('pwd', ''),
    }
    print(conn_params)
    # Então nos conectamos ao db (comentado)
    # db.connect(**conn_params)

connect()
connect(host='127.0.0.42', port=5433)
connect(port=5431, user='fab', pwd='gandalf')
```
Observe na função que podemos preparar um dicionário de parâmetros de conexão *(Conn_params)* na função usando valores padrão como 
retorno, permitindo que eles ser substituído se forem fornecidos na chamada de função.

Existem melhores maneiras de fazer isso com menos linhas de código, mas agora não estamos preocupados com isso. A execução do código
anterior produz o seguinte resultado:
```
$ python3 arguments.variable.db.py
{'host': '127.0.0.1', 'pwd': '', 'user': '', 'port': 5432}
{'host': '127.0.0.42', 'pwd': '', 'user': '', 'port': 5433}
{'host': '127.0.0.1', 'pwd': 'gandalf', 'user': 'fab', 'port': 5431}
```
Observe a correspondência entre as chamadas de função e a saída. Observe como os valores padrão estão lá ou substituídos, de acordo 
com o que foi passado para a função.

### Argumentos apenas para palavras-chave
O Python 3 permite um novo tipo de parâmetro: o parâmetro somente para palavras-chave. Nós vamos estudá-los apenas brevemente, pois 
seus casos de uso não são tão freqüentes. Há duas maneiras de especificá-las, quer após os argumentos posicionais variáveis, quer 
depois de um nulo *. Vamos ver um exemplo de ambos.

```
def kwo(*a, c):
    print(a, c)

kwo(1, 2, 3, c=7) # prints: (1, 2, 3) 7
kwo(c=4) # prints: () 4
# Kwo (1, 2) # quebra, sintaxe inválida, com o seguinte erro
# TypeError: kwo() faltando 1 argumento requerido somente para palavra-chave: 'c'

def kwo2(a, b=42, *, c):
    print(a, b, c)

kwo2(3, b=7, c=99) # prints: 3 7 99

kwo2(3, c=13) # prints: 3 42 13
# Kwo2 (3, 23) # quebra, sintaxe inválida, com o seguinte erro
# TypeError: kwo2 ()faltando 1 argumento requerido somente para palavras-chave: 'c'
```
Como antecipado, a função, kwo, assume um número variável de argumentos posicionais(a) e uma função somente de palavra-chave, c. Os resultados 
das chamadas são diretos e você pode descomentar a terceira chamada para ver o erro que o Python retorna. O mesmo se aplica à função, kwo2, 
que difere de kwo na medida em que leva um argumento de posição a, um argumento de palavra-chave b e, em seguida, um argumento de palavra-chave,
C. Você pode descomentar a terceira chamada para ver o erro.

Agora que você sabe como especificar diferentes tipos de parâmetros de entrada, vejamos como Você pode combiná-los em definições de funções.

### Combinando parâmetros de entrada
Você pode combinar parâmetros de entrada, desde que você siga estas regras de pedidos:































































































































































