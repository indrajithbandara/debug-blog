---
layout: post
title:  "Python - Part 3:  Iterando e Fazendo Decisões"
date:   207-06-16 12::55 -0300
categories: blog
---
No capítulo anterior, vimos os tipos de dados internos do Python. Agora que você é familiarizado com os dados em suas diversas 
formas e formas, é hora de começar a ver como um programa pode usá-lo.

**De acordo com a Wikipedia:**    
*Na ciência da computação, o fluxo de controle (ou, alternativamente, fluxo de controle) refere-se à especificação da ordem em que as instruções individuais, 
instruções ou chamadas de função de um programa imperativo são executadas ou avaliadas. 

Para controlar o fluxo de um programa, temos duas armas principais: condicional (também conhecida como ramificação) e looping. Podemos usá-las em muitos 
diferentes combinações e variações, mas neste capítulo, em vez de passar todas as várias formas possíveis dessas duas construções de forma "documentada", 
eu gostaria Em vez disso, dê-lhe o básico e então vou escrever alguns scripts pequenos com você. Desde o primeiro, veremos como criar um gerador de número 
primo rudimentar, enquanto no segundo, veremos como aplicar descontos aos clientes com base em cupons. Desta forma, você deve ter uma sensação melhor sobre
como a programação  ondicional e o looping pode ser usado.*

A ferramenta principal é a instrução *If*, que vem em diferentes formas e cores, mas basicamente, o que faz é avaliar uma expressão e, com base no resultado, escolhe
qual parte do código a ser executado. Como de costume, vejamos um exemplo:
```
late = True  
if late:  
    print("I need to call my manager")  
```
Este é possivelmente o exemplo mais simples: quando alimentado para a instrução *If*, o atraso funciona como uma expressão condicional, que é avaliada em um contexto 
booleano (exatamente como se nós estavamos chamando *bool (late)*).

Se o resultado da avaliação for *True*, então entramos no corpo de código imediatamente após a declaração *If*. Observe que a instrução de impressão está recuada: isso significa que
ela pertence a um escopo definido pela cláusula if. A execução deste código produz:
```
$ python3 conditional_1.py      
I need to call my manager  
```
Desde que Late é *True*, a declaração de impressão foi executada. Vamos expandir este exemplo:
```
late = False  
if late:  
    print("renan precisa de um manager")  
else:  
    print("renan nao precisa de um manager")  
                                  
```
Desta vez eu defini *late = False*, então, quando eu executo o código, o resultado é diferente:
```
$ python3 conditional_2.py  
renan nao precisa de um manager  
```
Dependendo do resultado da avaliação da expressão late, podemos entrar no bloco 1 ou bloco 2, mas não ambos. O bloco 1 é executado quando avaliado em verdadeiro, enquanto o
bloco 2 é executado quando avaliado em *False*. Tente atribuir *False/True*. Valores para o nome late, e veja como a saída para este código muda de acordo.

O exemplo anterior também apresenta a cláusula else, que se torna muito útil quando queremos fornecer um conjunto alternativo de instruções a serem executadas quando uma
expressão avalia como *False* dentro de uma cláusula *If*. A outra cláusula é opcional, como é evidente comparando os dois exemplos anteriores.

### Um especializado Else: Elif
Às vezes, tudo o que você precisa é fazer algo se uma condição for atendida (cláusula simples *If*). Outras vezes você precisa fornecer uma alternativa, caso a condição seja False
*(If/Else)*, mas há situações em que você pode ter mais de dois caminhos para escolher, então, desde que chamar o manager (ou não chamá-los) é um tipo de binário o exemplo
(ou você chama ou não), vamos mudar o tipo de exemplo e continue expandindo. Desta vez, nós decidimos porcentagens fiscais. Se minha renda for inferior a 10k,
Não pagarei impostos. Se for entre 10k e 30k, eu pagarei 20% de impostos. Se for entre 30k e 100k, vou pagar impostos de 35% e mais de 100k, vou (com prazer) pagar 45% de 
impostos. Vamos colocar Tudo isso no código bonito do Python:
```
income = 1500
if income < 1000:
    tax_coefficient = 0.0  #1
elif income < 30000:
    tax_coefficient = 0.2  #2
elif income < 100000:
    tax_coefficient = 0.35  #3
else:
   tax_coefficiet = 0.45     #4

print ('Eu paguei: ', income * tax_coefficient, 'em taxas')

$ python3 income.py 
Eu paguei:  300.0 em taxas

``` 
Passemos pelo exemplo linha a linha: começamos configurando o valor de renda(income). No exemplo, minha renda é 15k. Nós inserimos a cláusula *If*. Observe que desta vez nós
também introduziu a cláusula *Elif*, que é uma contração para mais-se e é diferente de uma outra cláusula else na medida em que também tem sua própria condição.

Então, a expressão *If* income < 10000, avaliamos *False*, portanto, o bloco 1 não é executado. O controle passa para o próximo avaliador da condição: renda elif < 30000. Este avalia
para Verdadeiro, portanto, o bloco # 2 é executado, e por isso, o Python então retoma execução após toda a cláusula *IFf/Elif/Elif/Else* (que podemos chamar apenas a cláusula *If*
a partir de agora). Existe apenas uma instrução após a cláusula IF, a impressão chamada, o que nos diz que pagarei 3k em impostos este ano (15k * 20%). Observe que a ordem
É obrigatóriia: IF primeiro, então(opcionalmente) os Elif conforme você precisa e, em seguida(opcionalmente) uma outra cláusula.

Interessante, certo? Não importa quantas linhas de código você possa ter dentro de cada bloco, quando uma das condições avalia para *True*, o bloco associado é executado
e então a execução é retomada após toda a cláusula. Se nenhuma das condições avalia como verdadeiro (por exemplo, *renda = 200000*), então o corpo da outra cláusula
seria executado (bloco # 4). Este exemplo amplia nossa compreensão do comportamento da outra cláusula. Seu bloco de código é executado quando nenhum dos precedendo If/Elif/.../Elif
expressões tenham sido avaliadas como *True*.

Tente modificar o valor da renda até que você possa executar todos os blocos com facilidade a sua vontade (uma por execução, é claro). E então tente os limites. Isso é crucial,
sempre que você tiver condições expressas como igualdades ou desigualdades *((==, !=, <, >, <= ,> =)*, Esses números representam limites. É essencial testar limites completamente. 
Devo permitir que você dirija às 18 ou 17? Estou a verificar a sua idade com Idade <18, ou idade <= 18? Você não pode imaginar quantas vezes eu tive que consertar erros sutis
Isso decorreu da utilização do operador errado, então vá em frente e experimente o código anterior. Altere alguns *<* para *<=* e defina a renda como um dos limites Valores 
(10k, 30k, 100k), bem como qualquer valor intermediário. Veja como o resultado muda, Tenha uma boa compreensão antes de prosseguir.

Antes de passar para o próximo tópico, vejamos outro exemplo que nos mostra como aninhar cláusulas *If*. Diga que seu programa encontre um erro. Se o sistema de alerta for o console,
nós imprimimos o erro. Se o sistema de alerta for um e-mail, nós o enviamos de acordo com a gravidade do erro. Se o sistema de alerta for diferente de console ou e-mail, nós não
sabemos o que fazer então não fazemos nada. Vamos colocar isso em código:
```
alert_system = 'console' #Outro valor pode ser 'email'  
erro_severity = 'critical' #Outros valores: 'médio' ou 'baixo'  
error_mensage = 'OMG!' #Algo terrível aconteceu!'  

if alert_system == 'console':  
    print (error_mensage) #1  
elif alert_system == 'email':  
    if error_severity == 'critical':  
        send_email ('@lorderenan.com1',  error_mensage) #2  
    elif erro_severity == 'medium':  
        send_email ('@renan@gostoso.com2', error_mensage) #3  
    else:  
        send_email('@lorderenan', error_mensage) #4  
```
O exemplo anterior é bastante interessante, em sua tolice. Mostra-nos duas aninhadas cláusulas *If*i (externas e internas). Também nos mostra que a cláusula *If* exterior não 
possui nenhum *Else*, enquanto o interior tem. Observe como a indentação é o que nos permite aninhar uma cláusula dentro de outra. 

*If alert_system == 'console'*, o escorpo 1 é executado, e nada mais acontece. Por outro lado, *If alert_system == 'email'*, então entramos em outro cláusula, que chamamos de interna.

Na cláusula *If* interna, de acordo com *error_severity*, Enviamos um e-mail para um administrador, suporte de primeiro nível ou suporte de segundo nível (Blocos  2, 3, 4). função 
*send_email* não está definida neste exemplo, portanto, tentar executá-lo daria um erro. No código-fonte do livro, que você pode baixar no site, incluí um truque para 
redirecionar essa chamada para uma função de impressão regular, apenas para que você possa experimentar no console sem realmente enviando um e-mail. Tente alterar os valores 
e veja como tudo funciona.

### O Operador Ternário
Uma última coisa que eu gostaria de mostrar antes de passar para o próximo assunto, é o o perador ternário *'OR'*, em termos leigos, a versão curta de uma cláusula *If/Else.
Quando o valor de um nome deve ser atribuído de acordo com alguma condição, às vezes é mais fácil e mais legível usar o operador ternário em vez de uma cláusula *If* apropriada.
No exemplo a seguir, os dois blocos de código fazem exatamente a mesma coisa:

``` 
order_total = 247  
  
#classic if/else  
if order_total > 100:  
    discount = 25  
ielse:  
    discount = 0  
print(order_total, discount)  
  
#operador Tenário  
discount = 25 if order_total > 100 else 0  
print(order_total, discount)  
```
Para casos simples como este, acho muito bom poder expressar essa lógica em uma única linha Em vez de quatro. Lembre-se, como um codificador, você passa muito mais
tempo lendo o código, então escrevendo, então a concisão de Python é inestimável. Ficou claro sobre o funcionamento do operador ternário? Basicamente, é 
nome = alguma coisa *If* condição, senão *Else* condição. Então, o nome é atribuído a alguma coisa se a condição *If* for igual a *True*, se for outra coisa, a  condição 
*IF* é avaliada como False.

### Looping
Se você tiver alguma experiência com looping em outras linguagens de programação, você encontre o modo de looping do Python um pouco diferente. Em primeiro lugar, 
o que é looping? Looping Significa poder repetir a execução de um bloco de código mais de uma vez, de acordo com os parâmetros de loop que nos são dados. Existem diferentes
construções de loop, que servem propósitos diferentes, e Python destilou todos eles para apenas dois, o que você Pode usar para alcançar tudo o que você precisa.
Estas são as declarações *For* e *while*. Embora seja definitivamente possível fazer tudo o que precisa usando qualquer um deles, eles Servem diferentes propósitos e, 
portanto, eles geralmente são usados em diferentes contextos.

### O Loop For
O loop *For* é usado ao fazer um loop sobre uma seqüência, como uma lista, uma *Tupla* ou uma coleção de objetos. Vamos começar com um exemplo simples que é mais como
o estilo C++ e, em seguida, Vamos ver gradualmente como conseguir os mesmos resultados em Python.

```
for number in [0, 1, 2, 3, 4]:
    print (number)
```
Este simples fragmento de código, quando executado, imprime todos os números de 0 a 4. O loop *For* é alimentado na lista *[0, 1, 2, 3, 4*] e em cada iteração,
o número é dado um valor da seqüência (que é iterado sequencialmente, na ordem), então o corpo do loop é executado ( A linha de impressão). Mudança de número em cada 
iteração, segundo a qual o valor vem próximo da sequência. Quando a seqüência está esgotada, o loop *For* para e termina a execução do código retoma normalmente com o 
código após o loop.

### Iterando em um Range
Às vezes, precisamos iterar em uma variedade de números, e seria bastante desagradável para ter que fazê-lo, escrevendo a lista em algum lugar.  Em tais casos, a função
de *Range* vem ao resgate. Vamos ver o equivalente ao anterior fragmento de  código:
```
for number in range(5):
    print (number)
```
$ python3 simple_for.py   
0  
1  
2    
3  
4  

A função *Range* é amplamente utilizada nos programas Python quando se trata de criar seqüências: você pode chamá-lo passando um valor que atua como parada(contando de 0), 
ou você pode passar dois valores (iniciar e parar), ou mesmo três (iniciar, parar e passo). Confira o seguinte exemplo:

list(range(10)  ) ** Um valor: de 0 para valor (excluído)**  
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

list(range(3, 8)) ** Dois valores: do início ao fim (excluído)**  
[3, 4, 5, 6, 7]  

list(range(-10, 10, 4)) ** Três valores: step é adicionado**  
[-10, -6, -2, 2, 6]  

Por enquanto, ignore que precisamos envolver o alcance(...) dentro de uma lista. O *Range* é um  objeto um pouco especial, mas neste caso, estamos apenas interessados em
entender quais são os valores que retornará para nós. Você vê que o negócio é o mesmo com cortar: O início está incluído, pare excluído e, opcionalmente, você pode adicionar 
um parâmetro de etapa, que por padrão é 1. Tente modificar os parâmetros da chamada *range()* em nosso código e veja o que ele imprime, fique confortável com ele.

### Iterando sobre uma sequência  
Agora, temos todas as ferramentas para iterar sobre uma seqüência, então vamos construir esse exemplo:
```
surnames = ['Riveste', 'Charmin', 'Adleman'] 
for position in range(len(surnames)):
    print(position, surnames[position])
```
O código anterior adiciona um pouco de complexidade ao jogo. A execução mostrará este resultado:

$ python3 simple_for.2.py  
0 Riveste  
1 Charmin    
2 Adleman    

Vamos usar a técnica de break para parar isso, ok? Começamos da parte mais interna do que estamos tentando entender e expandimos para fora então, *len(surnames)* 
é o comprimento da lista surnames ':3'. Portanto, *range(len(surnames))* irá transformalo em range(3). Isso nos dá o range [0, 3], que é basicamente uma seqüência(0, 1, 2). 
Isso significa que o loop for executará três iterações. No primeiro, a posição assumirá o valor 0, enquanto no segundo, ele tomará o valor 1 e, finalmente, valorará 2 na 
terceira e última iteração. O que é (0, 1, 2), se não as possíveis posições de indexação para a lista de sobrenomes? Na posição 0, encontramos 'Rivest', 
na posição 1, 'Shamir', e na posição 2, 'Adleman'. Se você tem curiosidade sobre o que esses três homens criaram juntos, mude a impressão (posição, sobrenome [posição]) 
para imprimir (sobrenomes [posição] [0], fim = '') adicione um *print()* no final fora do loop e execute o código novamente.

Agora, esse estilo de looping é realmente muito mais próximo de linguagens como Java ou C ++. Em Python, é bastante raro ver código como esse. Você pode simplesmente iterar 
sobre qualquer sequência ou coleção, portanto, não há necessidade de obter a lista de posições e recuperar elementos de uma seqüência em cada iteração. isso é custoso, 
Vamos mudar o exemplo para uma forma mais pythonic:
```
surnames = ['Rivest', 'Shamir', 'Adleman']
for surname in surnames:
    print(surname)
```
$ python3 simple_for.3.py  
Rivest  
Shamir    
Adleman    

Agora é algo assim! É praticamente inglês. O loop *For* pode iterar sobre a lista de sobrenomes e devolve cada elemento em cada interação. O loop *For* pode iterar sobre 
a lista de sobrenomes e devolve cada elemento em cada interação de  execução deste código imprimirá os três sobrenomes, um por vez. É muito mais fácil de ler, certo?
E se você quisesse imprimir a posição também? Ou se você realmente. Precisava por algum motivo? Você deve voltar ao *range(len (...)) Form?* Não. Você pode usar a função
 integrada enumerada, como esta: 
```
surnames = ['Rivest', 'Shamir', 'Adleman']
for position, surname in enumerate(surnames):
    print(position, surname)
``
$ python3 simple_for.4.py 
0 Rivest
1 Shamir
2 Adleman
```
Este código também é muito interessante. Observe que enumerar devolve uma 2-tupla (posição, sobrenome) em cada iteração, mas ainda assim, é muito mais legível do que o 
intervalo *(len (...))* por exemplo. Você pode chamar a função *enumerate* com um parâmetro de início, como enumerar(iterável, iniciar), e ele começará a partir do início,
em vez de 0. Usando um loop *For*, é possível iterar sobre listas, tuplas e, em geral, qualquer coisa desse tipo em Python é chamado iterable. Este é um conceito muito 
importante, então vamos falar sobre isso um pouco mais.

## Iterators e iterables
De acordo com a documentação do Python, uma iterável é: 

**"""**
Um objeto capaz de retornar seus membros de cada vez. Exemplos de iteraveis inclui todos os tipos de seqüência(como list, str e tuple) e alguns não-sequência tipos como *dict*,
objetos de arquivo e objetos de qualquer classe que você define com um método __iter__() ou __getitem __(). Iterables podem ser usados em um loop *For* e em muitos outros
locais onde uma seqüência é necessária *(zip(), map(),...)*. Quando o objeto iterável é passado como um argumento para a função incorporada *iter()*, ele retorna um iterador para
o objeto. Este iterador é bom para uma passagem sobre o conjunto de valores. Ao usar iterables, geralmente não é necessário chamar *iter()* ou lidar com os objetos do iterador. 
A declaração for faz isso automaticamente para você, criando uma variável temporária sem nome para manter o iterador durante a duração do loop ". 

Simplificando, o que acontece quando você escreve para k em sequência: ... Body ..., é que o loop for faz uma seqüência para o próximo elemento, ele recupera algo, ele chama isso
de algo k e então executa seu corpo.  Então, mais uma vez, o loop for faz uma seqüência novamente para o próximo elemento, ele o chama novamente e executa 
o corpo de novo, e assim por diante, até que a seqüência esteja esgotada. Seqüências vazias resultarão em zero execuções do corpo.

Algumas estruturas de dados, quando iniciadas, produzem seus elementos em ordem, como listas, tuplas e strings, enquanto outros não, como set e dicionários.

Python nos dá a capacidade de iterar sobre iterables, usando um tipo de objeto chamado *Iterador*. De acordo com a documentação oficial, um iterador é:

**"""**    
Um objeto que representa um fluxo de dados. Chamadas repetidas para o método interador __next__ (ou passar para a função incorporada *next()*) retornar itens sucessivos
no fluxo. Quando não há mais dados disponíveis, uma exceção *StopIteration* é levantada em vez disso. Neste ponto, o objeto do iterador está esgotado e outras chamadas para
seu método *__next __()* simplesmente crie *StopIteration* novamente. É necessário que os Iteradores tenham um método *__iter __()* que retorna o próprio objeto do iterador 
para que todos os iteradores também sejam iteráveis e possam ser usados na maioria dos lugares onde outros iterables são aceitaram. Uma exceção notável é o código que tenta 
a iteração múltipla passar. Um objeto contêiner(como uma lista) produz um novo iterador sempre que você passa para a função *iter()* ou use-o em um loop *For*. Tentando isso
com um iterador, retornará o mesmo objeto de iterador a exaustão usado na passagem de iteração anterior, fazendo com que pareça como um container vazio  
**"""**.    
Não se preocupe se você não entender completamente todos os legales anteriores, você irá em devido tempo. Posso aqui como uma referência prática para o futuro.
Na prática, todo o mecanismo iterável/iterador está um pouco escondido atrás do código. A menos que você precise codificar seu próprio iterável ou iterador por algum motivo, você
Não terá que se preocupar com isso demais.

Mas é muito importante entender como o Python lida com esse aspecto-chave do fluxo de controle porque irá moldar a maneira como você escreverá seu código.

### Iterando Sobre Múltiplas Sequências
Vamos ver outro exemplo de como iterar sobre duas seqüências do mesmo comprimento, a fim de trabalhar em seus respectivos elementos em pares. Digamos que temos uma lista de
pessoas e uma lista de números que representam a idade das pessoas na primeira lista.  Queremos imprimir um par pessoa/idade em uma linha para todos eles. Vamos começar com
um exemplo e vamos refiná-lo gradualmente.
```
people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
for position in range(len(people)):
    person = people[position]
    age = ages[position]
    print(person, age)
```
Até agora, este código deve ser bastante direto para você entender. Precisamos iterar sobre a lista de posições (0, 1, 2, 3) porque queremos recuperar elementos 
de duas listas diferentes. Executando-o, obtemos o seguinte:

$ python3 multi.sequences.py   
Jonas 25  
Julio 30  
Mike 31  
Mez 39  

Este código é ineficiente e não Pythonic. Inadequado porque recuperar um elemento dado a posição pode ser uma operação custosa, e estamos fazendo isso a partir do zero em cada iteração.
O homem do correio não volta ao início da estrada cada vez que entrega uma carta, certo? Ele se move de casa em casa. De um para outro. Vamos tentar torná-lo melhor usando enumerar:
```
people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
for position, person in enumerate(people):
   age = ages[position]
   print(person, age)
```
$ python3 multiple.sequences.enumerate.py   
Jonas 25  
Julio 30  
Mike 31  
Mez 39  

Melhor, mas ainda não perfeito. E ainda um pouco feio. Estamos iterando corretamente sobre as pessoas, mas ainda estamos buscando idade usando a indexação de posições, 
o que queremos perder também. Bem, não se preocupe, Python lhe dá a função zip, lembra? Vamos usá-lo!
```
people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
for person, age in zip(people, ages):
    print(person, age)
```
$ python3 multiple.sequences.zip.py   
Jonas 25  
Julio 30  
Mike 31  
Mez 39  

Ah! Muito melhor! Mais uma vez, compare o código anterior com o primeiro exemplo e admire a elegância de Python. A razão pela qual eu queria mostrar este exemplo é dupla.
Por um lado, queria dar-lhe uma ideia de como o código em Python é mais curto se comparado a outras linguagens, onde a sintaxe não permite que você faça iterar sobre 
seqüências ou coleções com facilidade.

E, por outro lado, e muito mais importante, note que, quando o loop for enviar *zip(sequenceA, sequenceB)* para o próximo elemento, ele recupera uma tupla, não apenas um único objeto.
Obtémos uma tupla com tantos elementos como o número de seqüências que alimentamos para a função *zip*. Vamos expandir um pouco no exemplo anterior de duas maneiras:
usando a atribuição explícita e implícita:
```
people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
nationalities = ['Belgium', 'Spain', 'England', 'Bangladesh']
for person, age, nationality in zip(people, ages, nationalities):
    print(person, age, nationality)
```
No código anterior, adicionamos a lista de nacionalidades. Agora que alimentamos três sequências para a função *zip*, o loop for retorna uma *3-tupla* em cada iteração.
Observe que a posição dos elementos na tupla respeita a posição das seqüências na chamada *zip*. A execução do código produzirá o seguinte resultado:

$ python3 multiple.sequences.explicit.py   
Jonas 25 Belgium  
Julio 30 Spain  
Mike 31 England  
Mez 39 Bangladesh  

Às vezes, por razões que podem não ser claras em um exemplo simples como o anterior, você pode querer explodir a tupla dentro do corpo do loop *For*. Se esse é o seu desejo, 
é perfeitamente possível fazê-lo.

```
people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
nationalities = ['Belgium', 'Spain', 'England', 'Bangladesh']
for data in zip(people, ages, nationalities):
    person, age, nationality = data
    print(person, age, nationality)
```
$ python3 multiple.sequences.explicit.py   
Jonas 25 Belgium  
Julio 30 Spain  
Mike 31 England  
Mez 39 Bangladesh  

É basicamente fazer o que o *loop* for faz automaticamente para você, mas em alguns casos você pode querer fazê-lo sozinho. Aqui, os dados de 3 tuplas que vem do zip (...), são explodidos
dentro do corpo do loop for em três variáveis: pessoa, idade e nacionalidade.

### O Loop While
Nas páginas anteriores, vimos o loop *For* em ação. É incrivelmente útil quando você precisa fazer um loop sobre uma seqüência ou uma coleção.
O ponto chave a ter em mente, quando você precisa ser capaz de discriminar qual construção de loop para usar, é que o loop for loop quando você precisa iterar sobre uma quantidade finita de elementos.
Pode ser uma grande quantidade, mas ainda assim, algo que em algum ponto termina.

Há outros casos, porém, quando você precisa apenas rolar até que alguma condição seja satisfeita, ou até mesmo *loop* indefinidamente até o aplicativo parar. Casos em que 
realmente não temos algo para iterar e, portanto, o loop for seria uma má escolha. Mas não tenha medo, para estes casos, o Python nos fornece o loop *While*. 

O loop *While* é semelhante ao loop *For*, na medida em que ambos fazem um *loop* e em cada iteração eles executam um conjunto de instruções. O que é diferente entre eles é que o 
loop *While* não faz um loop sobre uma seqüência (pode, mas você tem que escrever manualmente a lógica e não faria nenhum sentido, você gostaria apenas de usar um loop for), em vez
disso, ele faz loops enquanto uma determinada condição é satisfeita.

Como de costume, vejamos um exemplo que esclarecerá tudo para nós. Queremos imprimir a representação binária de um número positivo. Para fazê-lo, dividimos repetidamente o número por dois,
coletando o restante e, em seguida, produzimos o inverso da lista de restos. Deixe-me dar-lhe um pequeno exemplo usando o número 6, que é 110 em binário.

6 / 2 = 3 (remainder: 0)  
3 / 2 = 1 (remainder: 1)  
1 / 2 = 0 (remainder: 1)  

Lista de restos: 0, 1, 1.
Inverso é 1, 1, 0, que é também a representação binária de 6: 110

Vamos escrever algum código para calcular a representação binária para o número 39: 100111 2.

```
n = 39
remainders = []
while n > 0:
    remainder = n % 2 #resto da divisao de 2
    remainders.append(remainder) # acompanhamos os restos
    n //= 2 # nós dividimos n por 2

# Reatribua a lista à sua cópia invertida e imprima-a
remainders = remainders[::-1]
print(remainders)
```            
$ python3 binary.py   
[1, 0, 0, 1, 1, 1]

No código anterior, destaquei duas coisas: n > 0, que é a condição para manter o loop e os restos [:: - 1], que é uma maneira agradável e fácil de obter a
versão invertida de uma lista(parâmetros de início e final ausentes, step = -1, produz a mesma lista, de ponta a inicial, na ordem inversa).

Podemos tornar o código um pouco mais curto (e mais Pythonic), usando a função divmod, que é chamada com um número e um divisor, e retorna uma tupla com o 
resultado da divisão inteira e seu restante. Por exemplo, divmod (13, 5) retornaria (2, 3), e de fato 5 * 2 + 3 = 13.

```
n = 39
remainders = []
while n > 0:
    n, remainder = divmod(n, 2)
    remainders.append(remainder)

# reatribuindo a lista à sua copia inversa e imprimindo na tela
remainders = remainders[::-1]
print(remainders)

```
No código anterior, reatribuímos n ao resultado da divisão em 2, e o remaider, em uma única linha. Observe que a condição *In* um loop *While* é uma condição
para continuar o loop. Se ele for considerado verdadeiro, então o corpo é executado e depois outra avaliação segue, e assim por diante, até que a condição 
seja avaliada como *False*. Quando isso acontece, o loop é encerrado imediatamente sem executar seu corpo.
  
**"""** *Se a condição nunca for avaliada como *False*, o loop se torna o chamado loop infinito. Os loops infinitos são usados, por exemplo, quando se faz uma pesquisa 
de dispositivos de rede: você pergunta ao soquete se houver algum dado, você faz algo com ele se houver, então você dorme por um pequeno período de tempo e então
você pede o soquete novamente, Uma e outra vez, sem nunca parar.* **"""**  
  
Ter a capacidade de fazer um loop sobre uma condição, ou para loop indefinidamente, é a razão pela qual o loop for sozinho não é suficiente e, portanto, 
Python fornece o loop while.  
  
**"""** *Por sinal, se você precisar da representação binária de um número, check a função *Bin*.* **"""**  
    
Apenas por diversão, vamos adaptar um dos exemplos usando a lógica do *While*.
```
people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
position = 0
    while position < len(people):
    person = people[position]
    age = ages[position]

print(person, age)
position += 1
```
No código anterior, destaquei a inicialização, a condição e a atualização da posição da variável, o que possibilita a simulação do equivalente para o código do loop,
manipulando manualmente a variável de iteração. Tudo o que pode ser feito com um loop *For* também pode ser feito com um loop *While*, mesmo que você possa ver que
há um pouco de *Boilerplate* você tem que passar para conseguir o mesmo resultado.

O oposto também é verdadeiro, mas simular um loop de fim infinito usando um loop *For* requer algum truque real, então por que você faria isso? Use a ferramenta certa 
para o trabalho e 99,9% das vezes você estará bem.

Então, para recapitular, use um loop *For* quando você precisa iterar sobre um(ou uma combinação de) iterable e um loop *While* quando você precisa fazer um ciclo de 
acordo com uma condição que está sendo satisfeita ou não.

Se você tiver em mente a diferença entre os dois propósitos, você nunca escolherá a construção de loop errada. Vamos agora ver como alterar o fluxo normal de um loop.
Vamos agora ver como alterar o fluxo normal de um loop. 

### O Break e Continue das Declarações
De acordo com a tarefa em questão, às vezes você precisará alterar o fluxo regular de um loop. Você pode ignorar uma única iteração (quantas vezes quiser), ou você
pode sair do loop inteiramente. Um caso de uso comum para ignorar iterações é, por exemplo, quando você está iterando sobre uma lista de itens e você precisa trabalhar em cada um
somente se alguma condição for verificada. 

Por outro lado, se você estiver iterando sobre uma coleção de itens e você encontrou um deles que satisfaça algumas  necessidades que você precisa, você pode decidir 
não continuar o ciclo inteiramente e, portanto, sair disso. Existem inúmeros cenários possíveis, por isso é melhor ver alguns exemplos.

Digamos que você deseja aplicar um desconto de 20% a todos os produtos em uma lista de cesta para aqueles que têm uma data de validade de hoje. A maneira como você consegue 
isso é usar a declaração de continuação, que informa a construção de loop (*For ou While*) para interromper imediatamente a execução do corpo e ir para a próxima iteração,
se houver. Este exemplo nos levará um pouco mais profundo no buraco do coelho.
```
from datetime import date, timedelta
today = date.today()
tomorrow = today + timedelta(days=1) # hoje + 1 dia é amanhã
products = [
    {'sku': '1', 'expiration_date': today, 'price': 100.0},
    {'sku': '2', 'expiration_date': tomorrow, 'price': 50},
    {'sku': '3', 'expiration_date': today, 'price': 20},
]
for product in products:
    if product['expiration_date'] != today:
        continue
    product['price'] *= 0.8 # equivale a apicar 20% de desconto
    print(
        'Price for sku', product['sku'],
        'is now', product['price'])
```
Você vê que começamos importando os objetos data e timedelta, então nós setamos nossos produtos. Aqueles com sku 1 e 3 têm uma data de validade de hoje, o que significa que nós 
queremos aplicar 20% de desconto neles. Fazemos um loop sobre cada produto e inspecionamos a data de validade. Se não for 'today'(o operador de desigualdade, != )
não queremos executar o restante do corpo, então continuamos.

Observe que não é importante onde no conjunto de corpo você coloca a declaração continue, você pode até usa-lo mais de uma vez. Quando você alcança, a execução pára e volta 
para a próxima iteração.

$ python3 discount.py   
Price for sku 1 is now 80.0  
Price for sku 3 is now 16.0  

O que mostra que as últimas duas linhas do corpo não foram executadas para o número 2 do sku.  

Vamos agora ver um exemplo de sair de um loop. Digamos que queremos dizer que se, pelo menos, qualquer um dos elementos de uma lista é considerado verdadeiro
quando alimentado na função booleana. Dado que precisamos saber se há pelo menos uma, quando a encontramos, não precisamos continuar a procurar a lista. 
No código Python, isso se traduz em usar a indicação *break*. Vamos escrever isso em código:
```
items = [0, None, 0.0, True, 0, 7] # True e 7 avaliam True
found = False # isso é chamado "flag"
for item in items:
    print('buscado em item', item)
    if item:
        found = True # nós atualizamos o flag
        break
if found: # nós inspecionamos flag
    print('Pelo menos um item avalia como True')
else:
    print('Todos itens são avaliados como False')
```
O código anterior é um padrão comum na programação, você vai ver muito. Quando você inspeciona itens dessa maneira, basicamente, o que você faz é configurar uma variável *Flag*,
e em seguida, iniciar a inspeção. Se você encontrar um elemento que corresponda aos seus critérios (neste exemplo, que avalia como *True*), você atualiza o sinalizador e
interrompe a iteração. Após a iteração, você inspeciona o sinalizadori vai agir de acordo.

Rendimentos de execução:

$ python3 any.py  
buscado em item 0  
buscado em item None  
buscado em item 0.0  
buscado em item True  
Pelo menos um item avalia como True

Veja como a execução parou depois que *True* foi encontrado?

A declaração de interrupção age exatamente como a continuação, na medida em que pára de executar o corpo do *loop* imediatamente, mas também, impede que qualquer outra 
iteração seja executada, efetivamente saindo do loop.

As instruções de continuação e quebra podem ser usadas em conjunto com nenhuma limitação em seu número, tanto nas construções como para o loop.

**"""** Por sinal, não há necessidade de escrever código para detectar se há pelo menos um elemento em uma seqüência que avalia como *True*. Basta verificar a função incorporada.**"""**  

### Uma Cláusula Else Especial
Uma das características que eu vi apenas no idioma Python é a capacidade de ter cláusulas *Else* depois de *Whiles* e loops *For*. É muito raramente usado, 
mas definitivamente é bom ter. Em suma, você pode ter uma outra suite após um loop *For* ou *While*. Se o loop terminar normalmente, por causa do esgotamento 
do iterador (para *loop*) ou porque a condição finalmente não é atendida (loop *While*), então o suite *Else* (se presente) é executado. Isso significa que queremos 
prender a execução regular do programa e sinalizar que houve um erro, ou exceção, que não podemos lidar. As exceções serão objeto dos próximos capítulos, então não 
se preocupe se você não as entender completamente agora. Basta ter em mente que eles irão alterar o fluxo regular do código. Deixe-me mostrar-lhe agora dois exemplos 
que fazem exatamente o mesmo, mas um deles está usando o especial *For*... e a sintaxe *Else*. Digamos que queremos encontrar entre uma coleção de pessoas que
poderiam dirigir um carro.
```
class DriverException(Exception):  #CodeError
    pass
people = [('James', 17), ('Kirk', 9), ('Lars', 13), ('Robert', 8)]
driver = None
for person, age in people:
    if age >= 18:
        driver = (person, age)
        break

if driver is None:
    raise DriverException('Driver not found.')
```
Observe o padrão do *Flag* novamente.

Nós configuramos o driver para ser *None*, então, se encontrarmos um, atualizamos o sinalizador do driver e, no final do loop, inspecionamos para ver se um foi encontrado.
Tenho a sensação de que aquelas crianças dirigiriam um mecanismo metálico parecido com um carro, mas, de qualquer forma, observe que, se um driver não for encontrado,
um DriverException é gerado, sinalizando o programa que a execução não pode continuar (faltamos o driver).

A mesma funcionalidade pode ser reescrita um pouco mais elegante usando o seguinte código: 
```
class DriverException(Exception): #CodeError
    pass
people = [('James', 17), ('Kirk', 9), ('Lars', 13), ('Robert', 8)]
for person, age in people:
    if age >= 18:
        driver = (person, age)
        break
else:
    raise DriverException('Driver not found.')
```
Observe que não somos obrigados a usar o padrão *flag* mais. A exceção é gerada como parte da lógica de loop for, o que faz bom sentido porque o loop for está controlando alguma condição.
Tudo o que precisamos é configurar um objeto de driver caso encontremos um, porque o resto do código usará essa informação em algum lugar.

Tudo o que precisamos é configurar um objeto de driver caso encontremos um, porque o resto do código usará essa informação em algum lugar. Observe que o código é mais curto
e mais elegante, porque a lógica agora está corretamente agrupada onde pertence.

### Colocando tudo isso em conjunto

Agora que você viu tudo o que há para ver sobre condicionais e loops, é hora de apimentar um pouco e ver esses dois exemplos que eu antecipei no início deste capítulo. Vamos misturar 
e combinar aqui, para que você possa ver como se pode usar todos esses conceitos juntos.  Vamos começar escrevendo algum código para gerar uma lista de números primos até algum limite.
Tenho em mente que vou escrever um algoritmo muito ineficiente e rudimentar para detectar primos. O importante para você é concentrar-se nos bits do código que pertencem ao assunto 
deste capítulo.

#### Exemplo 1 - um gerador de numeros primos
Número primo é um número natural maior que 1 que não tem divisores positivos que não sejam 1 e ele próprio. Um número natural maior que 1 que não é um número primo
é chamado de número composto."

Com base nesta definição, se considerarmos os 10 primeiros números naturais, podemos ver que 2, 3, 5 e 7 são primos, enquanto que 1, 4, 6, 8, 9, 10 não são. Para que um computador 
diga se um número *N* é primo, você pode dividir esse número por todos os números naturais na faixa [2, N]. Se alguma dessas divisões rende zero como restante, então o número 
não é um primo. 

Vou escrever duas versões disso, o segundo dos quais explorará a sintaxe *For*... *Else*...
```
primes = [] #  Isso irá conter os primos no final
upto = 100 # O limite, inclusive
for n in range(2, upto + 1):
    is_prime = True # flag, novo adcionando para interação for
    for divisor in range(2, n):
        if n % divisor == 0:
            is_prime = False
            break
    if is_prime: # check on flag
        primes.append(n)
print(primes)
```
Em primeiro lugar, criamos uma lista vazia, que conterá os numeros primos no final do programa. O limite é 100, e você pode ver que é inclusivo
na forma como chamamos o *range()* no *loop* externo. Se escrevemos um *range(2, upto)* que seria *[2, upto)*, certo? Portanto, 
o alcance (2, upto + 1) nos dá [2, upto + 1] == [2, upto]. Então, dois para *loops*. 

No seguimos no corpo exterior,atrás dos candidatos a numeros primos, isto é, todos os números naturais a partir de  2 para cima. Dentro de cada iteração deste
loop externo, configuramos o *bag* (que é definido como *True* em cada iteração) e, em seguida, começa a dividir a corrente *n* por todos os 
números de 2 a n - 1. 

Se encontrarmos um divisor apropriado para *n*, significa que n é composto e,portanto, configuramos o *flag* como *False* e quebramos 
o *loop*. Observe que, quando rompemos o interior, o externo continua a funcionar normalmente. A razão pela qual rompemos depois de ter encontrado um divisor
apropriado para *n* é que não precisamos de mais informações para poder dizer que *n* não é um numero primo.

Quando verificamos o sinalizador *is_prime*, se ainda for *True*, significa que não conseguimos encontrar nenhum. Número em[2, n) que é um divisor apropriado para *n*, 
portanto, *n* é um primo. Nós anexamos *n* para a lista primitiva e o salto! Outra iteração, até *n* igual a 100.

Executando este código produz:

$ python3 primes.py   
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97

Antes de prosseguir, uma pergunta: de todas as iterações do circuito externo, uma delas é diferente de todas as outras. Você poderia dizer qual e por quê? Pense nisso por um segundo,
volte ao código e tente descobrir por si mesmo e, em seguida, continue lendo.  

Você descobriu isso? Caso contrário, não se sinta mal, é perfeitamente normal. Pedi-lhe que fizesse isso como um pequeno exercício porque é o que os codificadores fazem o tempo todo.
A habilidade para entender o que o código faz simplesmente olhando para ele é algo que você constrói ao longo do tempo. É muito importante, então tente exercitá-lo sempre que puder.

Eu direi a você a resposta agora: a iteração que se comporta de maneira diferente de todos os outros é a primeira.   A razão é porque na primeira iteração, n é 2.

Portanto, o loop mais interno não será executado, porque é um loop para que itera sobre o alcance (2, 2) e o que é isso, se não [2, 2]? Experimente por si mesmo, escreva 
um simples loop com isso iterável, coloque uma impressão na suíte do corpo e veja se alguma coisa acontece (não será ...).

Agora, de um ponto de vista algorítmico, esse código é ineficiente, então vamos torná-lo mais bonito: 
```
primes = []
upto = 100
for n in range(2, upto + 1):
    for divisor in range(2, n):
        if n % divisor == 0:
            break
    else:
        primes.append(n)
print(primes)
```
Muito melhor, né? O *flag* is_prime desapareceu completamente, e nós anexamos n para A lista de primos quando sabemos que o loop interno para não encontrou declarações de interrupção.
Veja como o código parece mais limpo e lê melhor?

### Exemplo 2 - aplicação de descontos
Neste exemplo, quero mostrar uma técnica que eu gosto muito.

Em muitas linguagens de programação, além das construções if/elif/else, em qualquer forma ou sintaxe que possam vir, você pode encontrar outra declaração, 
geralmente chamada switch/case, que em Python está faltando.

É o equivalente a uma cascata de cláusulas if/elif/.../elif/else, com uma sintaxe semelhante a este (aviso! Código JavaScript!):

switch (day_number) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        day = "Weekday";
        break;
    case 6:
        day = "Saturday";
        break;
    case 0:
        day = "Sunday";
        break;
    default:
        day = "";
        alert(day_number + ' is not a valid day number.')
}

No código anterior, alternamos uma variável chamada day_number. Isso significa que obtemos o seu valor e depois decidimos em que caso ele se encaixa(se houver). 
De 1 a 5, há uma cascata, o que significa que não importa o número, [1, 5], tudo para a pequena lógica que define o dia como "Dia da semana". Então, temos casos 
individuais para 0 e 6 e um caso padrão para. Evitar erros, que alertam o sistema que day_number não é um número de dia válido, ou seja, não em [0, 6].

Python é perfeitamente capaz de realizar essa lógica usando if/elif/else nas definições.

if 1 <= day_number <= 5:
    day = 'Weekday'
elif day_number == 6:
    day = 'Saturday'
elif day_number == 0:
    day = 'Sunday'
else:
    day = ''
    raise ValueError(
        str(day_number) + ' is not a valid day number.')

No código anterior, reproduzimos a mesma lógica do snippet de JavaScript, em Python, usando instruções if/elif/ else. Eu criei a exceção ValueError apenas como um
exemplo no final, se day_number não estiver em [0, 6]. Esta é uma maneira possível de traduzir a lógica switch / case, mas também há outra, 
às vezes chamada de despacho, que eu vou mostrar na última versão do próximo exemplo.

"""
Por sinal, você notou a primeira linha do fragmento anterior? Você notou que o Python pode fazer o dobro (na verdade, mesmo Múltiplas) comparações? É maravilhoso!
"""

Vamos começar o novo exemplo simplesmente escrevendo algum código que atribua um desconto aos clientes com base no valor do cupom. Eu vou manter a lógica até um
mínimo aqui, Lembre-se de que tudo o que realmente nos interessa é condicionais e loops. 
```
customers = [
    dict(id=1, total=200, coupon_code='F20'), #
    dict(id=2, total=150, coupon_code='P30'), #
    dict(id=3, total=100, coupon_code='P50'), #
    dict(id=4, total=110, coupon_code='F15'), #
]
for customer in customers:
    code = customer['coupon_code']
    if code == 'F20':
        customer['discount'] = 20.0
    elif code == 'F15':
        customer['discount'] = 15.0
    elif code == 'P30':
        customer['discount'] = customer['total']
    elif code == 'P50':
        customer['discount'] = customer['total']
    else:
        customer['discount'] = 0.0

for customer in customers:
    print(customer['id'], customer['total'], customer['discount'])
```
Começamos configurando alguns clientes. Eles têm um total de pedidos, um código de cupom e um id. Eu fiz quatro tipos diferentes de cupom, dois são fixos
e dois são baseados em porcentagem. Você pode ver que na cascata if/elif/else eu aplico o desconto conseqüentemente, eu configurei isso como
uma key de "desconto" no cliente. 

No final, apenas imprimo uma parte dos dados para ver se meu código está funcionando corretamente.

$ python3 coupons.py 
1 200 20.0
2 150 150
3 100 100
4 110 15.0

```
Este código é simples de entender, mas todas essas cláusulas estão meio que desordenando a lógica.
iii
Não é fácil ver o que está acontecendo a primeira vista, e não gosto disso.

Em casos como este, você pode explorar um dicionário em sua vantagem, assim:

customers = [
    dict(id=1, total=200, coupon_code='F20'), # F20: fixed, £20
    dict(id=2, total=150, coupon_code='P30'), # P30: percent, 30%  
    dict(id=3, total=100, coupon_code='P50'), # P50: percent, 50%
    dict(id=4, total=110, coupon_code='F15'), # F15: fixed, £15
]
discounts = {
    'F20': (0.0, 20.0), # each value is (percent, fixed)
    'P30': (0.3, 0.0),
    'P50': (0.5, 0.0),
    'F15': (0.0, 15.0),
}
for customer in customers:
    code = customer['coupon_code']
    percent, fixed = discounts.get(code, (0.0, 0.0))
    customer['discount'] = percent * customer['total'] + fixed

for customer in customers:
    print(customer['id'], customer['total'], customer['discount'])
```                                                            
A execução do código anterior produz exatamente o mesmo resultado que tivemos no trecho antes dele. Nós pouparamos duas linhas, mas, mais importante, 
ganhamos muito em legibilidade, já que o corpo do loop for agora tem apenas três linhas de comprimento e é muito fácil de entender.

O conceito aqui é usar um dicionário como expedidor, em outras palavras, tentamos buscar algo do dicionário com base em um código (coupon_code),
e usando o dict.get(key, value), nós nos certificamos de que também atendemos quando o código não está no dicionário e nós precisamos de um valor padrão.

Observe que eu tive que aplicar uma álgebra linear muito simples para calcular o desconto corretamente. Cada desconto tem uma porcentagem e 
parte fixa no dicionário, representada por uma 2-tupla. Quando o percentual é 0, a fórmula apenas dá a quantidade fixa, e dá porcentagem * total quando fixo é 0.
Simples mas efetivo. Essa técnica é importante porque também é usada em outros contextos, com funções, onde realmente se torna muito mais poderoso do que o que 
vimos no fragmento anterior.

Se não estiver completamente claro para você como isso funciona, eu sugiro que você aproveite seu tempo e experimente-o. Altere valores e adicione instruções de
impressão para ver o que está acontecendo enquanto o programa está sendo executado

#### Uma rápida olhada no módulo itertools
Um capítulo sobre iterables, iteradores, lógica condicional e looping não seria completo sem gastar algumas palavras sobre o módulo itertools. Se você tiver 
na iteração, isto é uma espécie de céu.

De acordo com a documentação oficial do Python, o módulo itertools é:

"""
Um módulo que implementa vários blocos de construção do iterador inspirados em construtores:  APL, Haskell, and SML. Cada um foi reformulado de uma forma adequada para Python.
O módulo padroniza um conjunto básico de ferramentas rápidas e eficientes em memória que são úteis por si mesmos ou em combinação. Juntos, eles formam uma "iteratoralgebra" 
que possibilita a construção de ferramentas especializadas de forma sucinta e eficiente em Python puro.
"""
De modo algum, eu tenho o quarto aqui para mostrar-lhe todos os presentes que você pode encontrar neste módulo, então eu encorajo você a ir e verificar isso por você mesmo, 
eu prometo que você vai gostar Em poucas palavras, fornece-lhe três grandes categorias de iteradores. Eu lhe darei um exemplo muito pequeno de um iterador tirado de cada um deles,
apenas para fazer sua água na boca um pouco.

#### Iteradores infinitos
Os iteradores infinitos permitem que você trabalhe com um loop for de forma diferente, como se fosse um loop while. 
```
from itertools import count
for n in count(5, 3):
    if n > 20:
        break
print(n, end=', ') # Em vez de newline, vírgula e espaço
``
Executar o código dá isso:

$ python3 infinite.py 
23

A classe de fábrica de contagem faz um iterador que apenas continua e está sendo contado. Começa a partir de 5 e continua adicionando 3 para ele. Precisamos quebrar manualmente se 
não quisermos ficar presos em um loop infinito.

### Iteradores terminando na sequência de entrada mais curta
Esta categoria é muito interessante. Ele permite que você crie um iterador baseado em vários iteradores, combinando seus valores de acordo com alguma lógica. O ponto chave aqui
é que, entre esses iteradores, caso algum deles seja mais curto do que o resto, o iterador resultante não irá quebrar, ele simplesmente  irá parar assim que o iterador mais curto
estiver esgotado. Isso é muito teórico, eu sei, então deixe-me dar-lhe um exemplo usando compress. Este iterador retorna os dados de acordo com um item correspondente em um seletor 
sendo True ou False:

Comprimir('ABC', (1, 0, 1)) daria 'A' e 'C', porque eles correspondem aos 1's. Vamos ver um exemplo simples:
```
from itertools import compress
data = range(10)
even_selector = [1, 0] * 10
odd_selector = [0, 1] * 10
even_numbers = list(compress(data, even_selector))
odd_numbers = list(compress(data, odd_selector))
print(odd_selector)
print(list(data))
print(even_numbers)
print(odd_numbers) 
```
Observe que odd_selector e even_selector têm 20 elementos de comprimento, enquanto data são apenas 10 elementos. A compressão irá parar logo que os dados tenham produzido seu último elemento.
A execução deste código produz o seguinte:

python3 compress.py 
[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 2, 4, 6, 8]
[1, 3, 5, 7, 9]

É uma maneira muito rápida e agradável de selecionar elementos de uma iterável. O código é muito simples, basta notar que em vez de usar um loop for para iterar sobre 
cada valor que é devolvido pelas chamadas de compressão, usamos list (), que faz o mesmo, mas em vez de executar um conjunto de instruções,
coloca Todos os valores em uma lista e retorna.

$ python3 compress.py 
[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 2, 4, 6, 8]
[1, 3, 5, 7, 9]

#### Geradores combinatórios
Por último, mas não menos importante, geradores combinatórios. Estes são realmente divertidos, se você estiver nesse tipo de coisa. Vamos ver um exemplo simples sobre permutações.
"Uma permutação, também chamada de" número de arranjo "ou" ordem ", é uma Rearranjo dos elementos de uma lista ordenada S em uma correspondência um-para-um Com o próprio S ".

Por exemplo, as permutações de ABC são 6: ABC, ACB, BAC, BCA, CAB e CBA. Se um conjunto tiver N elementos, então o número de permutações deles é N! (N factorial).
Para a string ABC as permutações são 3! = 3 * 2 * 1 = 6. Vamos fazê-lo em Python:
```
from itertools import permutations
print(list(permutations('ABC')))
```
$ python permutations.py
[('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]

Tenha muito cuidado ao jogar com a permutação. Seu número cresce a uma taxa proporcional ao fatorial do número de elementos que você está permutando, 
e esse número pode ser realmente grande, muito rápido

#### Resumo
Neste capítulo, demos um passo a frente para expandir nosso vocabulário de codificação. Vimos como impulsionar a execução do código, avaliando as condições, 
e vimos como fazer um loop e iterar sobre seqüências e coleções de objetos.

Isso nos dá o poder de controlar o que acontece quando o nosso código é executado, o que significa que estamos tendo uma idéia sobre como moldá-lo para que 
ele faça o que queremos e reage aos dados que mudam dinamicamente.

Também vimos como combinar tudo em um par de exemplos simples e, no final, tomamos uma breve olhada no módulo itertools, que é cheio de iteradores interessantes 
que podem enriquecer ainda mais nossas habilidades com Python.

Agora é hora de trocar engrenagens, dar mais um passo em frente e falar sobre funções

O próximo capítulo é sobre eles porque eles são extremamente importantes. Certifique-se de estar confortável com o que foi feito até agora: eu quero lhe fornecer exemplos interessantes, então eu vou ter que ir um pouco mais rápido. Pronto? Vire a página.



































































































































































































































































































































































































































































