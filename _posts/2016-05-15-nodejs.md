---
layout: post
title:  "NodeJS - Primeiros Passos !"
date:   2016-05-17 09:32:03 -0300
categories: start blog
---

O NodeJS é tipo uma plataforma, ele não é uma coisa só, e como ele funciona? 
Se vc olhar essa imagem vai vê que o NodeKS se comunica com o V8 
e também comm a LIBUV que gerencia essa parte de Envent Loop a fila que vamos vê tudo isso.
[Imgur](http://i.imgur.com/BXonCXX.png)

Basicamente ele é um  interpretador de JavaScript que funciona do lado do servidor 
criado em cima do V8 que é o motor de JavaScript do Chrome e como uma ponte entre uma API
acessável via JavaScript.

O Node.js pode ser considerado uma plataforma de execução de aplicações em JavaScript no 
lado do servidor.

O Node.js age como uma ponte entre uma API acessável via JavaScript e funções em C++ do V8, foi criado por Ryan Dahl em 2009.

##### V8
Ele é nada menos que o interpretador de JavaScript, tipo uma máquina virtual, desenvolvido pelo Google e usado no Chrome. Feito em C++ e open-source.

#####  Single Thread
O Node.js trabalha apenas com uma thread, podendo ser criadas outras, com isso economizando muita memória, diferentemente da forma que o Apache trabalha 

##### Event Loop
O Event Loop nada mais é que uma fila infinita que recebe todos os eventos emitidos pelo Node.js, isso inclui as requisições que recebemos no servidor HTTP.

Quando o evento chega para ser exeutado no *Event Loop*, caso ele seja assíncrono, ele será enviado para onde deve ser executado, por exemplo: filesystem, network, process, etc.Quando

Como o processo é assíncrono ele irá executar e só após sua finalização que ele dispara o trigger para seu callback, esse voltando para a fila que irá ser executada pelo Event Loop.Como

##### I/O Async
Qualquer função do Node.js, por padrão, é assíncrona por isso sempre precisamos de uma função que executará após o final desse processamento,
essa que executa posteriormente é chamada de callback.

#### Libuv
O mesmo acontece com nossos sistemas, quando você envia uma requisição assíncrona você não tem a certeza quando ela irá retornar, por isso usamos Promises, mas isso é um assunto posterior.
Essa biblioteca veio para fazer o trabalho da libev e libeio agregando também a parte de DNS do C-Ares.
Onde a libev gerenciava o Event Loop e a libeio gerenciava o I/O assíncrono.
Foi no Node 0.5 que ela entrou em cena e na versão 0.9 a libev foi removida.

#### I/O Async
Qualquer função do Node.js, por padrão, é assíncrona por isso sempre precisamos de uma função que executará após o final desse processamento, essa que executa posteriormente é chamada de callback, falaremos muito mais sobre isso futuramente.
Mas então o que quer dizer que o I/O é assíncrono?
Basicamente diz que qualquer leitura ou escrita de dados não espera seu processo finalizar para continuar o script, nesse caso os processos ocorrem “paralelamente” à execução.
Para termos uma ideia melhor de como é o funcionamento assíncrono, vamos pensar um restaurante sendo síncrono.
No restaurante síncrono quando uma mesa é atendida ela precisa receber seu pedido antes que o garçom possa antender outra mesa!!!
Agora no restaurante assíncrono o mesmo garçom pode atender vários pedidos e enviá-los para a cozinha. 

#### Thread Pool
O node js cria uma thread pool de tamanho fixo.
Uma idle thread, um i/o

#### Event Driven
GUI PATTERN
Node também é orientado a eventos

#### API
Tem como base o unix
A API dele é extensivamente modularizada, tem modulo para HTTP, tem modulo para filesystem, OpenSSl, TCP  e etc

## Parte 2 

#### HTTP
O módulo http é o principal módulo da nossas aplicações pois é com ele que criamos um servidor web para fornecer nossos sistemas. Ele trabalha com diversas funcionalidades do protocolo HTTP, porém não iremos abranger todas.

Ele trabalha com diversas funcionalidades do protocolo HTTP, porém não iremos abranger todas.

Esse é um módulo nativo, não necessitando que seja instalado anteriormente.

###### Como Usar? 
Para utilizar esse módulo basta importá-lo para seu
código:
require('http')dulo

Cada requisição enviada possui cabeçalhos que dizem o que essa requisição faz, vamos ver um
exemplo de uma requisição GET.

GET / HTTP/1.1
Host: webschool.io
Connection: close
User-Agent: Chrome/46.0.2490.86
Accept-Encoding: gzip
Accept-Charset: ISO-8859-1,UTF-8;q=0.7,*;q=0.7
Cache-Control: no
Accept-Language: de,en;q=0.7,en-us;q=0.3
Referer:Referer

HTTP/1.1 200 OK
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html
Date: Sun, 06 Dec 2015 01:07:17 GMT
ETag: W/"55f9df1c-23f"
Last-Modified: Wed, 16 Sep 2015 21:29:00 GMT
Server: nginx
Transfer-Encoding: chunked

Note na primeira linha onde recebemos: HTTP/1.1 200 OK. Esse 200 é o código de status da nossa resposta,
falarei mais adiante sobre.

Então perceba que o cliente envia uma requisição com um verbo HTTP e seus cabeçalhos, depois de
recebida e tratada o servidor responde com um STATUS CODE e seus cabeçalhos.

##### Metodos
O protocolo HTTP possui um conjunto de métodos/verbos que o cliente pode invocar, veja
abaixo a lista dos verbos mais usados:

GET
Requisita um representação do recurso especificado (O mesmo recurso pode ter várias representações, ao
exemplo de serviços que retornam XML e JSON)

HEAD
Retorna os cabeçalhos de uma resposta (sem o corpo contendo o recurso)

POST
Envia uma entidade e requisita que o servidor aceita-a como subordinada do recurso identificado pela URI.PUT
Requisita que uma entidade seja armazenadaembaixo da URI fornecida. Se a URI se refere a um
recurso que já existe, ele é modificado; se a URI não aponta para um recurso existente, então o servidor
pode criar o recurso com essa URI.

PUT
Requisita que uma entidade seja armazenadaembaixo da URI fornecida. Se a URI se refere a um
recurso que já existe, ele é modificado; se a URI não aponta para um recurso existente, então o servidor
pode criar o recurso com essa URI.

DELETE
Apaga o recurso especificado.

TRACE
Ecoa de volta a requisição recebida para que o cliente veja se houveram mudanças e adições feitas por
servidores intermediários.

OPTIONS
Retorna os métodos HTTP que o servidor suporta para a URL especificada.

CONNECT
Converte a requisição de conexão para um túnel TCP/IP transparente, usualmente para facilitar
comunicação criptografada com SSL (HTTPS) através de um proxy HTTP não criptografado.












